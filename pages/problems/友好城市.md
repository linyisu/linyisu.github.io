---
title: 友好城市
math: true
tags:
  - 动态规划
categories:
  - 题解
abbrlink: 26234
date: 2025-02-05 23:45:01
---

### 友好城市

##### 题目描述

Palmia国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的`$N$`个城市。

北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。

每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。

编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。

##### 输入格式

第`$1$`行，一个整数`$N$`，表示城市数。

第`$2$`行到第`$n+1$`行，每行两个整数，中间用`$1$`个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。

##### 输出格式

仅一行，输出一个整数，表示政府所能批准的最多申请数。

##### 数据范围

`$1 \leq N \leq 5000,$`

`$0\leq x_i \leq 10000$`

##### 输入样例

```
7
22 4
2 6
10 3
15 12
9 8
17 17
4 2
```

##### 输出样例

```
4
```

##### 思路

每一组申请装在一个`pair`里,按照第一关键词排序，求第二关键词的最长上升子序列。

##### CODE

```cpp
void solve()
{
    int n;  cin >> n;
    vector<pair<int, int>> prs(n);
    for (int i=0;i<n;i++)
        cin >> prs[i].first >> prs[i].second;
    sort(all(prs));

    int ans = 0;
    vector<int> v(n), dp(n, 1);
    for (int i=0;i<n;i++)   v[i] = prs[i].second;
    for (int i=0;i<n;i++)
    {
        for (int j=0;j<i;j++)
            if (v[i] > v[j])
                dp[i] = max(dp[i], dp[j] + 1);
        ans = max(ans, dp[i]);
    }
    cout << ans;
}
```

