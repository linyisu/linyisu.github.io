---
title: 4+ 高阶数据结构
math: true
cover: https://ooo.0x0.ooo/2025/08/22/OfdSUM.png
tag: 树分治 点分树 树链剖分 可持久化数据结构
categories: 算法与数据结构
date: 2025-08-18
updated: 2025-08-22
---

## 引入——树的重心
什么是**树的重心**呢，和物理学上的重心类似，如果我们挑选**某个节点**作为树的根节点的话，剩下的各个子树大小会**相对接近**，这就是树的重心

定义：
1. 以某个节点为根时，**最大子树的节点数最少**，则该节点是**重心**
2. 以某个节点为根时，**每棵子树的节点数不超过总结点数的一半**，则该节点是**重心**
3. 以某个节点为根时，**所有节点都走向该节点的总边数最少**，则该节点是**重心**，如果有两个重心，那么到它们的距离和一样

补充性质：
1. 一棵树**最多有两个重心**，若有两个重心，则两重心**一定相邻**
2. 如果树上增加或删除一个叶节点，转移后的重心**最多移动一条边**
3. 如果两棵树连起来，那么新树的重心一定在原来两棵树**重心的路径上**
4. 树上的边权若都为非负数，则不管边权如何分布，所有节点都走向重心的**总距离和最小**

既然如此，我们应该如何求得树的重心呢
考虑性质 1 ，**`dfs`一次**，算出以每个点为根的**子树的大小**，记录以每个结点为根的**最大子树的大小**，判断：如果以当前结点为根的最大子树大小比当前根更优，**更新当前根**

在主函数调用前，需要对 `wei[0]` **初始化一个极大值**，保证 `cent` 可以被正常更新

### 模板例题：[POJ Godfather](https://vjudge.net/problem/POJ-3107)
```cpp
// 寻找树的重心
// u: 当前 DFS 到的节点
// f: u 的父节点, 防止反向 DFS
void getCent(int u, int f)
{
    // 初始化当前节点 u 的信息
    siz[u] = 1; // 子树大小至少包含自己
    wei[u] = 0; // u 的最大子树大小

    // 遍历 u 的所有邻居
    for (auto v : adj[u])
    {
        if (v == f) // 不走向父节点
            continue;
        
        // 递归处理子节点
        getCent(v, u);
        
        // 回溯时更新 u 的信息
        siz[u] += siz[v]; // 累加子树大小
        wei[u] = max(wei[u], siz[v]); // u 的最大子树大小, 可能是其某个孩子的子树大小
    }
    
    // 考虑来自父节点方向的子树
    wei[u] = max(wei[u], sum - siz[u]); // sum - siz[u]:整个树去掉 u 子树后的大小
    
    // 6. 更新全局最优解(重心)
    if (wei[u] < wei[cent]) // 若 u 作为根时, 其最大子树比当前重心的更小
        cent = u; // 则 u 是一个更优的重心
}

// 调用示例
{
    cent = 0; // cent = 0 是虚拟节点, 其 wei 值极大
    wei[cent] = sum = n; // 初始化 wei[0] 为极大值, 保证第一个节点总能成为初始重心
    getCent(1, 0); // 从节点 1 开始 dfs , 假设其父节点为 0
}
```
## 树分治 (Tree Divide and Conquer)

**树分治**是一种在树形结构上应用**分治思想**的算法，它的核心思想是通过找到树的**重心**作为**分治中心**，将原问题**分解**为**若干个规模更小的、相互独立的子问题**

由于每次选择重心都能保证子问题的规模**至少减半**，递归深度严格控制在 **$\mathcal O(\log n)$** 以内，树分治通常能将原本 **$\mathcal O(n^2)$** 的暴力算法优化到 **$\mathcal O(n \log n)$** 或 **$\mathcal O(n \log^2 n)$**

根据选择的**分治中心**不同，树分治主要分为两种：**点分治**和**边分治**
### 点分治

**点分治**是树分治中最常用的一种，它的核心思想源于一个处理树上路径问题的简单观察：
> 一棵树上的路径，可按其是否经过根节点，划分为两类：
> 1. **经过根节点的路径**
> 2. **不经过根节点的路径**

对于**不经过根节点的路径**，它们必然完整地处于根节点删去后形成的**某棵子树**中，而对于这些子树，我们又可以**递归**地使用同样的方法进行处理

这启发我们得到一个**分治**算法的雏形：
1. 处理**经过当前根节点**的所有**路径**
2. **删掉根节点**，对生成的每棵子树**重复**以上步骤

这个想法看起来不错，对于一棵比较平衡的树，递归深度是 $\mathcal O(\log n)$，总时间复杂度也接近 $\mathcal O(n\log n)$，**但是**，如果树**退化成了一条链**，每次我们选择端点作为根，子问题的规模仅仅减小了 $1$，递归深度变成了 $\mathcal O(n)$，算法的时间复杂度将**退化为 $\mathcal O(n^2)$**

那么，如何确保每次划分都是“**平衡**”的呢，这正是**树的重心**发挥作用的地方
我们不选择任意节点作为根，而是选择当前树（或子树）的**重心**，根据重心的性质，以它为根时，最大子树的大小**不会超过总结点数的一半**，这就保证了每次分治后，子问题的规模**至少减半**，递归深度**严格控制在 $\mathcal O(\log n)$ 以内**

于是，我们的步骤就优化成了标准的**点分治算法**：
1. 找到当前树的**重心**，并以其为**根节点**
2. 处理所有**经过该重心的路径**，**统计**其对答案的**贡献**
3. **删除**该重心
4. 对于所有生成的子树，**递归**地重复以上步骤
#### 模板例题：[洛谷 P3806 【模板】点分治 1](https://www.luogu.com.cn/problem/P3806)

给定一棵带边权的树，询问树上是否存在距离为 `k` 的点对

这是一个典型的**路径统计问题**，点分治的核心是将路径分为**经过当前分治重心 `rt` 的**和**完全在 `rt` 的某个子树内的**，我们只需在每次分治时，专注于处理第一种情况（通常通过**容斥**计算），第二种情况交给**递归**解决

- `getDis(u, f)`：辅助的`DFS`函数，从节点 `u` 出发，遍历所有可达节点，计算它们到当前分治块起点的距离（该距离已预先存在 `d[u]` 中），并将所有这些距离**收集到 `dep` 数组**中
- `getSum(u, dis, ok)`：
	1. 设置起始点`u`的距离`d[u] = dis`
	2. 调用`getDis`收集所有相关距离到`dep`数组
	3. 对`dep`数组**排序**
	4. 对每一个查询`ipt[i]`，使用**双指针** `l` 和 `r` 在`dep`数组中寻找是否存在一对距离，其和为`ipt[i]`
	5. 如果找到了这样一对距离，`ans[i]` 就加上 `ok` 的值（`+1`或`-1`），实现了**容斥**的加减操作
- `f(u)`：
	1. **标记**：`vis[u] = true;` 将当前重心 `u` 标记为已处理，相当于从图中 **“删除”**
	2. **“包含”**：`getSum(u, 0, 1);` 这是**容斥的第一步**，它计算出**所有**经过 `u` 的路径（暂时不区分路径两端是否在同一子树），并将它们的贡献标记为`+1`
	3. **“排斥”**：随后的 for 循环遍历 `u` 的每个孩子 `v`，`getSum(v, w, -1);` 是**容斥的第二步**，它专门计算两端点**都在** `v` 这棵子树内的路径，并将它们的贡献标记为 `-1`，这样就把步骤2中**错误包含**的路径排除了
	4. **“分治”**：在 `for` 循环的后半部分，对每个子树**递归**进行点分治，找到子树的**新重心**，然后调用 `f(rt)`
##### 完整代码
```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
#define IOS ios::sync_with_stdio(0), cin.tie(0)
using namespace std;

const int N = 1e4 + 5;
int n, m;
vector<int> ipt, ans; // ipt: 存储 m 个查询的 k 值， ans: ans[i] > 0 表示第 i 个查询有解
int sum, rt; // sum: 当前分治块的总节点数，rt: 当前分治块的重心
vector<bool> vis; // vis[i] = true 表示节点 i 已作为重心被处理过
vector<int> siz, wei; // siz[u]: dfs 时以 u 为根的子树大小，wei[u]: 以 u 为根时,其最大子树的大小
vector<int> d, dep; // d[u]: dfs 时节点 u 到分治起点的距离,dep: 临时数组, 收集当前处理的子树中所有节点到分治起点的距离

vector<vector<pair<int, int>>> adj; // 存图

// 初始化全局变量和数据结构
void init()
{
    ipt.resize(n + 1);
    ans.resize(n + 1);
    adj.resize(n + 1);

    vis.resize(n + 1);
    siz.resize(n + 1);
    wei.resize(n + 1);

    d.resize(n + 1);
    dep.resize(n + 1);

    for (int i = 0; i <= n; i ++)
        vis[i] = ans[i] = false;
}

// 在当前分治块中寻找重心
void getCent(int u, int f) // u: 当前 DFS 到的节点, f: u 的父节点
{
    siz[u] = 1;
    wei[u] = 0;
    for (auto [v, _] : adj[u])
    {
        // 不走向父节点, 也不走向已经处理过的重心(已被"删除")
        if (v == f || vis[v])
            continue;
        getCent(v, u);
        siz[u] += siz[v];
        wei[u] = max(wei[u], siz[v]);
    }
    wei[u] = max(wei[u], sum - siz[u]);
    if (wei[u] < wei[rt])
        rt = u;
}

// 辅助 DFS , 收集一个块内所有节点到起点的距离
void getDis(int u, int f) // u: 当前节点, f: 父节点
{
    // 将 u 到起点的距离存入 dep 数组, dep[0] 作为计数器
    dep.emplace_back(d[u]);
    for (auto [v, w] : adj[u])
    {
        if (v == f || vis[v])
            continue;
        d[v] = d[u] + w;
        getDis(v, u);
    }
}

// 计算一个块内路径对答案的贡献 (容斥核心)
// u: 当前块的起始节点, dis: u 到分治重心的距离
// ok: 容斥系数, +1 代表增加贡献, -1 代表排除贡献
void getSum(int u, int dis, int ok)
{
    d[u] = dis;
    dep.clear();
    getDis(u, 0);
    // 排序距离数组, 为双指针做准备
    sort(dep.begin(), dep.end());
    for (int i = 1; i <= m; i ++)
    {
        int l = 0, r = dep.size() - 1;
        while (l < r)
        {
            if (dep[l] + dep[r] > ipt[i])
                r --;
            else if (dep[l] + dep[r] < ipt[i])
                l ++;
            else
            {
                // 找到满足条件的配对
                long long cnt1 = 1, cnt2 = 1; 
                while (l + 1 < r && dep[l] == dep[l + 1])
	                l ++, cnt1 ++;
	            while (r - 1 > l && dep[r] == dep[r - 1])
		            r --, cnt2 ++;
		        int t = cnt1 + cnt2;
		        ans[i] += ok * (dep[l] != dep[r] ? cnt1 * cnt2 : t * (t - 1) / 2);
		        l ++, r --;
            }
        }
    }
}

// 点分治的递归主函数
void f(int u) // u: 当前分治块的重心
{
    // "删除"当前重心, 并计算所有经过 u 的路径的贡献
    vis[u] = true;
    getSum(u, 0, 1);
    for (auto [v, w] : adj[u])
    {
        if (vis[v])
            continue;
        // 容斥: 排除掉两端点都在 v 子树内的路径
        getSum(v, w, -1);

        // 分治: 对 v 子树进行新的点分治
        rt = 0;
        sum = wei[rt] = siz[v]; // siz[v] 是在上一层 getCent(u,...) 中正确计算的
        getCent(v, 0);
        f(rt);
    }
}

void solve()
{
    cin >> n >> m;
    init();
    for (int i = 1, u, v, w; i < n; i ++)
    {
        cin >> u >> v >> w;
        adj[u].emplace_back(v, w);
        adj[v].emplace_back(u, w);
    }
    for (int i = 1; i <= m; i ++)
        cin >> ipt[i];

    // 初始化重心, 使得第一个节点能被选为重心
    rt = 0;
    sum = wei[rt] = n;
    getCent(1, 0); // 找到整棵树的重心
    f(rt); // 从重心开始分治
    for (int i = 1; i <= m; i ++)
	    println("{}", ans[i] > 0 ? "AYE" : "NAY"); // 根据 ans[i] 是否大于 0 来判断是否存在解
}

int main()
{
    IOS;
    solve();
    return 0;
}
```
### 边分治

**边分治**是另一种树分治的实现，与点分治选择一个“**重心**”来划分问题不同，边分治选择一条“**重边**”作为分治中心

它的核心思想是：寻找一条边，使得**删去这条边**后，形成的两棵子树**大小尽可能接近**，然后，我们将所有路径分为两类：
1. **经过** 这条重边的路径
2. **不经过** 这条重边，即**完全包含在其中一棵子树内**的路径

对于第一类路径，我们**跨越这条边**来统计答案；对于第二类路径，我们**递归**地在两个子树中继续进行边分治
#### 与点分治的比较
* **优点**：边分治每次严格地将问题分为**两个**子问题，在处理跨越分治中心的路径时，逻辑比点分治（可能分为多个子问题）要**更简单**
* **缺点**：边分治对树的形态有要求，在**菊花图**上，不存在任何一条能平衡分割树的边，会导致算法退化成 **$\mathcal O(n^2)$**，因此，应用边分治通常需要先通过 **“三度化”** 等技巧将原树转化为一棵**二叉树**，增加了实现的复杂度

[![OfdAXC.md.png](https://ooo.0x0.ooo/2025/08/22/OfdAXC.md.png)](https://img.tg/image/OfdAXC)
## 点分树
点分治算法虽然高效，但它是一个**离线算法**，一旦树的结构或者边权发生**修改**，整个分治结构就需要**重新计算**

为了解决这个问题，**点分树**（也叫**动态点分治**）应运而生，它将点分治过程中产生的**重心关系**，构建成一棵**新的、深度为 $\mathcal O(\log n)$ 的树**，从而将对原树的操作转化为对这棵新树的操作，以支持**在线修改和查询**

点分树的核心在于**将查询/修改操作分解到点分树的祖先链上**，对于原树的一个节点 `u` 的操作，我们只需要**沿着 `u` 在点分树上的祖先链**，一直走到根，并更新/查询这条路径上每个节点所维护的数据结构（通常是树状数组或平衡树），并利用**容斥原理**来合并/消除贡献

### 模板例题：[洛谷 P6329 【模板】点分树 | 震波](https://www.luogu.com.cn/problem/P6329)

给定一棵有 $n$ 个点的点权树，有 $q$ 次操作，每次操作修改一个点权或询问所有与点 $x$ 距离小于等于 $k$ 的点的点权之和。
强制在线两个操作：
1. **单点修改**：修改树上一个节点的权值
2. **距离查询**：查询与某个节点 `x` 的距离在 `k` 以内的所有节点的权值和

这是一道带修改的树上距离查询问题，需要在线处理，是点分树的典型应用

核心思路是在点分树的每个节点 `u` 上，维护两个**树状数组**：
- `a`: 维护 `u` 分治块内所有节点 `v` 的权值，以 `dist(u, v)` 为下标
- `b`: 维护 `u` 分治块内所有节点 `v` 的权值，以 `dist(fa[u], v)` 为下标 (`fa[u]` 是 `u` 在点分树上的父亲)，用于容斥

查询 `(x, k)` 时，从 `x` 沿点分树向上跳到祖先 `u`，在 `u` 的 `a` 中加上贡献，同时在 `u` 的父节点的计算中，通过 `u` 的 `b` 减去重复计算的贡献
#### 完整代码
```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
#define IOS ios::sync_with_stdio(0), cin.tie(0)
using namespace std;

// 树状数组模板
template <typename T> struct BIT
{
    int n;
    vector<T> tree;
    BIT(int siz = 0) : n(siz) { tree.assign(n + 1, T{}); }
    // 单点修改: pos 位置增加 delta
    void modify(int pos, T delta)
    {
        if (pos < 0 || pos >= n)
            return;
        pos ++;
        for (; pos <= n; pos += pos & (-pos))
            tree[pos] += delta;
    }
    // 前缀查询: 查询 [0, pos] 的和
    T query(int pos)
    {
        if (pos < 0)
            return T{};
        pos = min(pos, n - 1);
        pos ++;
        T sum = T{};
        for (; pos > 0; pos -= pos & (-pos))
            sum += tree[pos];
        return sum;
    }
    // 区间查询: 查询 [l, r] 的和
    T query(int l, int r)
    {
        if (l > r)
            return T{};
        if (l == 0)
            return query(r);
        return query(r) - query(l - 1);
    }
};

// 点分树每个节点维护的数据结构
// a: 存储分治块内节点到当前重心的距离
// b: 存储分治块内节点到父重心的距离
struct node { BIT<int> a, b; };

int rt; // 全局变量, 用于在找重心时记录重心
vector<int> val; // 原树节点权值
vector<node> points; // 点分树, points[i] 对应节点 i 的数据结构
vector<vector<int>> adj; // 邻接表存原树

// 使用倍增法求 LCA
namespace LCA
{
    int lgn;
    vector<int> dep; // 节点深度
    vector<vector<int>> fa; // fa[u][i] 表示 u 的第 2^i 个祖先
    void init(int n)
    {
        lgn = log2(n) + 1;
        dep.assign(n + 1, 0);
        fa.assign(n + 1, vector<int>(lgn + 1));
    }
    void dfs(int u, int f)
    {
        dep[u] = dep[f] + 1;
        for (auto v : adj[u])
        {
            if (v == f)
                continue;
            fa[v][0] = u; // v 的父亲是 u
            for (int i = 1; i <= lgn; i ++)
                fa[v][i] = fa[fa[v][i - 1]][i - 1]; // 预处理倍增数组
            dfs(v, u);
        }
    }
    int lca(int u, int v)
    {
        if (dep[u] < dep[v])
            swap(u, v);
        // 将 u 跳到和 v 同一深度
        for (int i = lgn; i >= 0; i --)
            if (dep[fa[u][i]] >= dep[v])
                u = fa[u][i];
        if (u == v)
            return u;
        // u 和 v 一起向上跳
        for (int i = lgn; i >= 0; i --)
            if (fa[u][i] != fa[v][i])
            {
                u = fa[u][i];
                v = fa[v][i];
            }
        return fa[u][0];
    }
}

// 获取 u 和 v 在原树的距离
int getDis(int u, int v) { return LCA::dep[u] + LCA::dep[v] - 2 * LCA::dep[LCA::lca(u, v)]; }

// 点分树构建
namespace Tree_Divide
{
    int n, sum;
    vector<bool> vis; // vis[i]=true 表示 i 已是分治重心
    vector<int> siz, wei, fa; // 子树大小, 最大子树大小, 点分树父亲

    void init(int n_nodes)
    {
        n = n_nodes;
        fa.resize(n + 1);
        siz.resize(n + 1);
        wei.resize(n + 1);
        vis.assign(n + 1, false);
    }

    void getCent(int u, int f)
    {
        wei[u] = 0;
        siz[u] = 1;
        for (auto v : adj[u])
        {
            if (v == f || vis[v])
                continue;
            getCent(v, u);
            siz[u] += siz[v];
            wei[u] = max(wei[u], siz[v]);
        }
        wei[u] = max(wei[u], sum - siz[u]);
        if (wei[u] < wei[rt])
            rt = u;
    }
    
    // 找到一个大小为 cnt 的连通块的重心
    void getRoot(int v, int cnt)
    {
        rt = 0;
        sum = cnt;
        wei[rt] = cnt; // 初始化虚拟重心
        getCent(v, 0);
        getCent(rt, 0); // 第二次调用以确保 siz 数组正确
    }

    // 递归构建点分树
    // u: 当前重心, f: 点分树父亲, cnt: 当前分治块大小
    void build(int u, int f, int cnt)
    {
        fa[u] = f;
        vis[u] = true;
        // 初始化BIT, 大小需要足够容纳块内所有可能的距离
        if (f)
            points[u].b = BIT<int>(getDis(u, f) + cnt + 1);
        points[u].a = BIT<int>(cnt + 1);
        sum = cnt;
        getCent(u, 0); // 运行一次以计算所有子树的 siz
        for (auto v : adj[u])
        {
            if (vis[v])
                continue;
            int tmp = siz[v];
            getRoot(v, tmp); // 在 v 子树中找到新的重心 rt
            build(rt, u, tmp); // 递归构建
        }
    }
}

// 主逻辑
void solve()
{
    int n, m;
    cin >> n >> m;
    adj.resize(n + 1);
    val.resize(n + 1);
    for (int i = 1; i <= n; i ++)
        cin >> val[i];
    for (int i = 1, u, v; i < n; i ++)
    {
        cin >> u >> v;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    
    // 预处理 LCA
    LCA::init(n);
    LCA::dfs(1, 0);
    // 构建点分树
    Tree_Divide::init(n);
    Tree_Divide::getRoot(1, n); // 找到整棵树的重心
    points.assign(n + 1, node{});
    Tree_Divide::build(rt, 0, n); // 从根开始构建

    // 初始化点分树的 BIT 数据
    for (int i = 1; i <= n; i ++)
    {
        // 沿着点分树向上更新
        for (int u = i; u; u = Tree_Divide::fa[u])
        {
            int d1 = getDis(i, u);
            points[u].a.modify(d1, val[i]); // 更新对重心 u 的贡献
            if (Tree_Divide::fa[u])
            {
                int d2 = getDis(i, Tree_Divide::fa[u]);
                points[u].b.modify(d2, val[i]); // 更新对父重心 fa[u] 的贡献
            }
        }
    }

    long long ans = 0;
    for (int i = 1, op, x, y; i <= m; i ++)
    {
        cin >> op >> x >> y;
        x ^= ans, y ^= ans; // 在线解密
        if (op == 0) // 查询
        {
            ans = 0;
            int pre = 0;
            // 沿着点分树向上, 进行容斥计算
            for (int u = x; u; u = Tree_Divide::fa[u])
            {
                int d = getDis(x, u);
                if (y >= d)
                {
                    // "加": 加上 u 分治块的贡献
                    ans += points[u].a.query(y - d);
                    // "减": 如果不是第一层, 减去子块 pre 的重复贡献
                    if (pre)
                        ans -= points[pre].b.query(y - d);
                }
                pre = u;
            }
            println("{}", ans);
        }
        else if (op == 1) // 修改
        {
            int del = y - val[x];
            val[x] = y;
            // 沿着点分树向上, 更新权值变化量
            for (int u = x; u; u = Tree_Divide::fa[u])
            {
                int d1 = getDis(x, u);
                points[u].a.modify(d1, del);
                if (Tree_Divide::fa[u])
                {
                    int d2 = getDis(x, Tree_Divide::fa[u]);
                    points[u].b.modify(d2, del);
                }
            }
        }
    }
}

int main()
{
    IOS;
    solve();
    return 0;
}
```
## 树链剖分 (Heavy-Light Decomposition)
### 重链剖分

**树链剖分**是一种能将对**树上任意一条路径**或**任意一个子树**的操作转化为**若干个连续区间**上的操作的算法，从而让我们能够使用**线段树**、**树状数组**等数据结构来高效处理树上问题
#### 核心概念
树链剖分的核心在于将一棵树**拆分**成若干条不相交的路径（链），使得我们可以快速地在这些路径上进行操作，为此我们引入了以下概念：
- **重儿子**：一个父节点的所有儿子中，**子树节点数目最多**的那个儿子
- **轻儿子**：父节点中**除重儿子以外**的其他儿子
- **重边**：父节点和**重儿子**连接成的边
- **轻边**：父节点和**轻儿子**连接成的边
- **重链**：由**多条重边**连接而成的路径
[![OfdrLN.png](https://ooo.0x0.ooo/2025/08/22/OfdrLN.png)](https://img.tg/image/OfdrLN)
通过这些定义，我们可以得到几个重要的性质：
1. 整棵树会被剖分成**若干条重链**
2. **轻儿子**一定是**每条重链的顶点**（链头）
3. 从根到任意节点的路径上，经过的**轻边**和**重链**都不会超过 **$\mathcal O(\log n)$** 条，为**路径操作**的复杂度提供了保证
4. **一个节点的子树，其 `dfn` 序是连续的**，为**子树操作**的复杂度提供了保证
#### `dfs1` && `dfs2`
树链剖分的实现主要分为两次 `DFS`：
1.  **第一次 `DFS` (`dfs1`)**:
    -   处理出每个节点的**父节点 `fa`**、**深度 `dep`**、**子树大小 `siz`**
    -   根据子树大小，找出每个节点的**重儿子 `son`**
2.  **第二次 `DFS` (`dfs2`)**:
    -   为每个节点分配一个**新的编号 `dfn`** (`DFS`序)，这个编号是**连续的**，目的是将树上操作转化为序列上的区间操作
    -   确定每个节点所在**重链的顶点 `top`**
    -   在 `dfs2` 中，我们**优先遍历重儿子**，这样可以保证**同一条重链上的所有节点的 `dfn` 编号是连续的**

完成这两次 `DFS` 后：
- 树上的任意一条**路径 `(u, v)`** 就可以被拆分成 $\mathcal O(\log n)$ 段**连续的 `dfn` 区间**
- 树上的任意一个**子树 `u`** 就可以被映射为**一个单独的、连续的 `dfn` 区间** `[dfn[u], dfn[u] + siz[u] - 1]
#### 利用树链剖分求LCA
在进行了两次 `DFS` 预处理之后，我们可以利用 `top` 和 `fa` 数组在 $\mathcal O(\log n)$ 的时间内求出任意两点的最近公共祖先 (`LCA`)

基本思想是：**不断地将深度更深的点向上跳，直到两点在同一条重链上**，此时深度较小的那个点就是它们的 `LCA`
##### 模板例题：[# P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
```cpp
int lca(int u, int v)
{
    // 当 u 和 v 不在同一条重链上时
    while (top[u] != top[v])
    {
        // 优先让深度更深的点向上跳
        // 它会跳到自己所在重链顶点的父节点上
        if (dep[top[u]] < dep[top[v]])
            swap(u, v);
        u = fa[top[u]];
    }
    // 当 u 和 v 在同一条重链上时, 深度小的点即为 lca
    return dep[u] < dep[v] ? u : v;
}
```
#### 模板例题：[洛谷 P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)

对一颗给定的点权树，要求支持四种操作：
1.  将树上 `x` 到 `y` 的**路径**上所有节点的值加上 `z`
2.  查询树上 `x` 到 `y` 的**路径**上所有节点的值之和
3.  将以 `x` 为根的**子树**中所有节点的值加上 `z`
4.  查询以 `x` 为根的**子树**中所有节点的值之和
##### 完整代码
```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
#define IOS ios::sync_with_stdio(0), cin.tie(0)
using namespace std;

int MOD; // 模数

// 带懒标记的线段树模板
template <typename T, class Info, class Laz> struct SegTree 
{
    int n;
    vector<T> arr; // 存储映射到线段树上的初始值
    vector<Laz> laz; // 懒标记数组
    vector<Info> info; // 线段树节点信息数组
    SegTree() : n(0) {}
    void init(int n_) { n = n_, arr.resize(n + 5), laz.resize(n << 2), info.resize(n << 2); }
    // 构建线段树
    void build() { build(1, n, 1); }
    void build(int l, int r, int u) 
    {
        if (l == r) { info[u] = Info(arr[l]); return; }
        int mid = (l + r) >> 1;
        build(l, mid, u << 1);
        build(mid + 1, r, u << 1 | 1);
        push_up(u);
    }
    // 将懒标记应用到节点
    void apply(int u, Laz tag, int len) 
    {
        laz[u].apply(tag);
        info[u].apply(tag, len);
    }
    // 向上更新父节点信息
    void push_up(int u) { info[u] = info[u << 1] + info[u << 1 | 1]; }
    // 向下传递懒标记
    void push_down(int u, int llen, int rlen) 
    {
        apply(u << 1, laz[u], llen);
        apply(u << 1 | 1, laz[u], rlen);
        laz[u] = Laz(); // 清空父节点懒标记
    }
    // 区间修改
    void modify(int l, int r, Laz tag) { modify(l, r, tag, 1, n, 1); }
    void modify(int jobl, int jobr, Laz tag, int l, int r, int u) 
    {
        if (jobl <= l && jobr >= r) { apply(u, tag, r - l + 1); return; }
        int mid = (l + r) >> 1;
        push_down(u, mid - l + 1, r - mid);
        if (jobl <= mid) modify(jobl, jobr, tag, l, mid, u << 1);
        if (jobr > mid) modify(jobl, jobr, tag, mid + 1, r, u << 1 | 1);
        push_up(u);
    }
    // 区间查询
    Info query(int l, int r) { return query(l, r, 1, n, 1); }
    Info query(int jobl, int jobr, int l, int r, int u) 
    {
        if (jobl <= l && jobr >= r) return info[u];
        int mid = (l + r) >> 1;
        push_down(u, mid - l + 1, r - mid);
        if (jobl <= mid && jobr > mid) return query(jobl, jobr, l, mid, u << 1) + query(jobl, jobr, mid + 1, r, u << 1 | 1);
        else if (jobl <= mid) return query(jobl, jobr, l, mid, u << 1);
        else if (jobr > mid) return query(jobl, jobr, mid + 1, r, u << 1 | 1);
        return Info();
    }
};
// 懒标记结构体, 这里只支持区间加
struct Laz 
{
    long long add = 0;
    void apply(const Laz &tag) 
    { 
        if (tag.add) 
            add = (add + tag.add) % MOD; 
    }
};
// 线段树节点信息结构体, 这里只维护区间和
struct Info 
{
    long long sum = 0;
    Info() {}
    Info(long long x) : sum(x) {}
    void apply(const Laz &tag, int len) 
    { 
        if (tag.add) 
            sum = (sum + tag.add * len % MOD) % MOD; 
    }
    // 定义节点合并操作
    Info operator+(const Info &a) const 
    {
        Info res;
        res.sum = (sum + a.sum) % MOD;
        return res;
    }
};

int n, m, r; // 节点数, 操作数, 根节点
vector<int> val; // 节点初始权值
vector<vector<int>> adj; // 邻接表

int cnt = 0; // DFS 序计数器
vector<int> fa, son, dep, siz; // dfs1 所求数组 fa: 父节点, son: 重儿子, dep: 深度, siz: 子树大小
vector<int> dfn, top; // df2 所求数组 dfn: DFS序, top: 所在重链的顶点

SegTree<int, Info, Laz> seg; // 线段树

// 第一次 DFS: 计算 fa, dep, siz, son
void dfs1(int u, int f)
{
    siz[u] = 1;
    fa[u] = f, dep[u] = dep[f] + 1;
    for (auto v : adj[u])
    {
        if (v == f)
            continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[v] > siz[son[u]]) // 如果 v 的子树比当前重儿子的子树还大, 更新重儿子
            son[u] = v;
    }
}

// 第二次 DFS: 计算 dfn, top
void dfs2(int u, int t)
{
    top[u] = t; // u 所在重链的顶点是 t
    dfn[u] = ++ cnt; // 分配 DFS 序
    seg.arr[dfn[u]] = val[u]; // 将初始值映射到线段树数组

    if (!son[u]) // 如果没有重儿子, 说明是叶子节点, 直接返回
        return;
        
    // 优先遍历重儿子, 保证重链上的 dfn 连续
    dfs2(son[u], t);

    // 遍历轻儿子
    for (auto v : adj[u])
    {
        if (v == fa[u] || v == son[u])
            continue;
        // 每个轻儿子都是一条新重链的顶点
        dfs2(v, v);
    }
}

// 路径修改: 将 u 到 v 的路径上所有节点值加 k
void modifyPath(int u, int v, int k)
{
    // 不断向上跳, 直到 u 和 v 在同一条重链上
    while (top[u] != top[v])
    {
        // 优先跳深度更深的点
        if (dep[top[u]] < dep[top[v]])
            swap(u, v);
        // 修改 u 所在重链的一部分(从 top[u] 到 u)
        seg.modify(dfn[top[u]], dfn[u], {k});
        // 跳到链头的父节点, 进入另一条链
        u = fa[top[u]];
    }
    // 此时 u 和 v 在同一条重链上
    if (dep[u] > dep[v])
        swap(u, v);
    seg.modify(dfn[u], dfn[v], {k});
}
// 路径查询: 查询 u 到 v 的路径上所有节点值的和
Info queryPath(int u, int v)
{
    Info res;
    while (top[u] != top[v])
    {
        if (dep[top[u]] < dep[top[v]])
            swap(u, v);
        res = res + seg.query(dfn[top[u]], dfn[u]);
        u = fa[top[u]];
    }
    if (dep[u] > dep[v])
        swap(u, v);
    return res + seg.query(dfn[u], dfn[v]);
}
// 子树修改: 将以 u 为根的子树中所有节点值加 k
void modifySubtree(int u, int k) 
{ 
    // 子树的 dfn 编号是连续的, 区间为 [dfn[u], dfn[u] + siz[u] - 1]
    // 直接对这个单一、连续的区间进行修改
    seg.modify(dfn[u], dfn[u] + siz[u] - 1, {k}); 
}
// 子树查询: 查询以 u 为根的子树中所有节点值的和
Info querySubtree(int u) 
{ 
    // 直接查询这个单一、连续的区间
    return seg.query(dfn[u], dfn[u] + siz[u] - 1); 
}

// 利用树链剖分求 lca
int lca(int u, int v)
{
    while (top[u] != top[v])
    {
        if (dep[top[u]] < dep[top[v]])
            swap(u, v);
        u = fa[top[u]];
    }
    return dep[u] < dep[v] ? u : v;
}

// 初始化
void init(int n)
{
    seg.init(n);
    val.resize(n + 1);
    adj.resize(n + 1);

    fa.resize(n + 1);
    siz.resize(n + 1);
    son.resize(n + 1);
    dep.resize(n + 1);
    top.resize(n + 1);
    dfn.resize(n + 1);
}

// 主逻辑
void solve()
{
    cin >> n >> m >> r >> MOD;
    init(n);
    for (int i = 1; i <= n; i ++)
    {
        cin >> val[i];
        val[i] %= MOD;
    }
    for (int i = 1, u, v; i < n; i ++)
    {
        cin >> u >> v;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }

    // 两次 dfs, 预处理所需数组
    dfs1(r, 0);
    dfs2(r, r);
    seg.build(); // 线段树建树

    int op, x, y, z;
    for (int i = 1; i <= m; i ++)
    {
        cin >> op;
        if (op == 1) // 路径修改
        {
            cin >> x >> y >> z;
            modifyPath(x, y, z);
        }
        else if (op == 2) // 路径查询
        {
            cin >> x >> y;
            println("{}", queryPath(x, y).sum);
        }
        else if (op == 3) // 子树修改
        {
            cin >> x >> z;
            modifySubtree(x, z);
        }
        else if (op == 4) // 子树查询
        {
            cin >> x;
            println("{}", querySubtree(x).sum);
        }
    }
}

int main()
{
    IOS;
    solve();
    return 0;
}
```
#### 边权转点权
树链剖分和我们使用的线段树都是基于**点权**的，但很多题目操作的对象是**边权**，这时就需要一个转换技巧：**将每条边的权值，赋给它深度更深的那个端点**

例如，对于边 `(u, v)`，如果 `dep[u] < dep[v]`，那么这条边的权值就变成了 `v` 点的点权
这样转换后：
- **修改边 `(u, v)` 的权值**：等价于修改深度更深的那个点（假设是 `v`）的点权
- **查询路径 `(u, v)` 的边权和**：等价于查询路径上所有点的点权和，但需要**排除LCA的点权**，因为 `lca(u, v)` 的点权代表的是 `(fa[lca], lca)` 这条边的权值，而这条边不在这条路径上
##### 模板例题：[洛谷 P3038 [USACO11DEC] Grass Planting G](https://www.luogu.com.cn/problem/P3038)
```cpp
// 路径修改: 将 u 到 v 的路径上所有节点值加 k
void modifyPath(int u, int v, int k)
{
    // 不断向上跳, 直到 u 和 v 在同一条重链上
    while (top[u] != top[v])
    {
        // 优先跳深度更深的点
        if (dep[top[u]] < dep[top[v]])
            swap(u, v);
        // 修改 u 所在重链的一部分(从 top[u] 到 u)
        seg.modify(dfn[top[u]], dfn[u], {k});
        // 跳到链头的父节点, 进入另一条链
        u = fa[top[u]];
    }
    // 此时 u 和 v 在同一条重链上
    if (dep[u] > dep[v])
        swap(u, v);
    seg.modify(dfn[u] + 1, dfn[v], {k}); // +1 跳过 lca
}
// 路径查询: 查询 u 到 v 的路径上所有节点值的和
Info queryPath(int u, int v)
{
    Info res;
    while (top[u] != top[v])
    {
        if (dep[top[u]] < dep[top[v]])
            swap(u, v);
        res = res + seg.query(dfn[top[u]], dfn[u]);
        u = fa[top[u]];
    }
    if (dep[u] > dep[v])
        swap(u, v);
    return res + seg.query(dfn[u] + 1, dfn[v]); // +1 跳过 lca
}
```
### 长链剖分
长链剖分是树链剖分的一种，它根据子树的**最大深度**来对树进行链的划分。

与**重链剖分**（根据子树大小 `size` 剖分）不同，**长链剖分**的核心指标是 `len`，即节点子树内的最大深度。这种独特的划分方式使得它在处理与“深度”相关的树上问题时具有天然的优势，尤其是在优化特定类型的树形DP和实现 $\mathcal O(1)$ 查询 `k`级祖先等问题上。
#### 核心概念
* **`len[u]`**: 表示以 $u$ 为根的子树中，节点能达到的最大深度。换句话说，它是从 $u$ 出发能走到的最远叶子节点的距离。
* **长儿子 (`son[u]`)**: 节点 $u$ 的所有儿子 $v$ 中，$len[v]$ 值最大的那个儿子。如果有多个儿子的 $len$ 值相同，任选其一即可。
* **长链**: 由父子关系和长儿子关系构成的极大路径。每条长链都以一个非长儿子的节点（或根节点）开始，然后沿着长儿子一直延伸到叶子节点。
* **链顶 (`top[u]`)**: 节点 $u$ 所在长链中深度最小的那个节点。
#### `dfs1` &&`dfs2`
长链剖分的构造通常通过两次 DFS 完成。
* **第一次 DFS (`dfs1`)**:
    * **目标**: 计算出每个节点的 `dep`（深度）和 `len`（子树最大深度），并确定每个节点的长儿子 `son`。
    * **过程**: 这是一个自底向上的过程。在回溯时，利用已经计算好的儿子信息来更新当前节点。一个节点 $u$ 的 `len` 值由其长儿子的 `len` 值决定：$len[u] = len[son[u]] + 1$。
* **第二次 DFS (`dfs2`)**:
    * **目标**: 连接长链，确定每个节点的 `top`（链顶）。
    * **过程**: 这是一个自顶向下的过程。当从节点 $u$ 遍历其儿子时：
        * **优先递归长儿子**: 将 $u$ 的 `top` 值直接传递给长儿子 $son[u]$，即 `dfs2(son[u], top[u])`。这保证了同一条长链上的所有节点拥有相同的链顶。
        * **处理轻儿子**: 对于其他轻儿子 $v$，它将成为一条新长链的链顶，因此从它开始新的递归：`dfs2(v, v)`。
#### 性质 与 应用
1.  树中所有长链的节点数之和为 $O(n)$。因为每个节点仅属于一条长链。
2.  从任意节点 $u$ 向上跳 $k$ 步到达的祖先 $v$，其所在长链的长度一定**大于等于** $k$。这是长链剖分能够 $O(1)$ 查询 $k$ 级祖先的理论基础。
3.  **$O(1)$ 查询树上 $k$ 级祖先** (在 $O(n \log n)$ 或 $O(n)$ 预处理后)。
4.  **优化与深度相关的树形 DP**，可将一些 $O(n^2)$ 的复杂度优化到 $O(n)$。
#### 模板例题：[# P5903 【模板】树上 K 级祖先](https://www.luogu.com.cn/problem/P5903)

给定一棵 $n$ 个点的有根树。有 $q$ 次强制在线询问，每次给定 $x$​, $k$​，$\mathcal O(1)$ 时间内求出点 $x$​ 的 $k$​ 级祖先。

查询节点 $x$ 的 $k$ 级祖先的核心思想是先用**倍增法**跳一大步，然后利用**长链剖分预处理**的信息在 $O(1)$ 时间内完成剩余的小跳。
**具体步骤**如下：
1.  找到小于等于 $k$ 的最大二次幂，记为 $2^{clz}$。
2.  从 $x$ 向上跳 $2^{clz}$ 步到达节点 `cur = st[x][clz]`。
3.  此时，还需要向上跳的距离是 $k' = k - 2^{clz}$。
4.  找到 `cur` 所在长链的链顶 `tp`。
5.  然后通过 `up` 和 `down` 数组在链 `tp` 上进行 $O(1)$ 的偏移查找。

**证明：为什么在 `cur` 点一定可以通过 `up` 和 `down` 数组找到答案？**
关键在于证明剩余需要跳的步数 $k'$ 一定小于 `cur` 所在长链的长度，即 $k' < len(top[cur])$。
1.  **最大二次幂的性质**：
    我们知道 $2^{clz} \le k < 2^{clz+1}$。
    因此，剩余步数 $k' = k - 2^{clz}$ 满足 $0 \le k' < 2^{clz+1} - 2^{clz} = 2^{clz}$。
    所以我们得到了一个关键的不等式：$k' < 2^{clz}$。
2.  **长链剖分的性质**：
    `len[u]` 定义为以 $u$ 为根的子树中的最大深度。在长链剖分中，一个节点 $u$ 的长儿子 $son[u]$ 是其所有儿子中 `len` 值最大的那个。
    从节点 $u$ 所在的链（从链顶到链尾）往下走，`len` 值是严格递减的，每次减 $1$。
    考虑节点 `cur` 和它的父亲 `fa = st[cur][0]`。`cur` 所在的长链长度 `len[top[cur]]` 至少是 `dep[cur] - dep[top[cur]] + 1`。
    更重要的是，`cur` 往上跳 $2^{clz}$ 步到达了 $x$ 的 $2^{clz}$ 级祖先。这意味着 $x$ 在 `cur` 的子树中，且 `cur` 到 $x$ 的距离是 $2^{clz}$。
    根据 `len` 的定义，`len[cur]` 是 `cur` 子树中的最大深度，所以 `len[cur]` 至少是以 `cur` 为根，沿着到 $x$ 的路径再继续往下走到底的长度。因此，$len[cur] \ge dep(x) - dep(cur) = 2^{clz}$。

3.  **推导**：
    我们已经知道 $k' < 2^{clz}$ 和 $len[cur] \ge 2^{clz}$。所以可以得到 $k' < len[cur]$。
    `cur` 节点所在长链的长度为 `len[top[cur]]`。从 `cur` 沿长链向上走到链顶 `top[cur]` 的距离是 `dep[cur] - dep[top[cur]]`。
    `len[top[cur]]` 是整条长链的长度，它等于从 `top[cur]` 走到链尾的距离，也等于 `len[top[cur]] = (dep[cur] - dep[top[cur]]) + len[cur]`。
    因为 $k' < len[cur]$，所以 $k'$ 必然小于从 `cur` 能向上或向下移动的总范围，因此查询一定不会超出 `top[cur]` 这条长链所预处理的 `up` 和 `down` 数组的范围。

**结论**：经过一次倍增跳跃后，剩余的距离一定小于当前节点所在子树的最大深度，也就保证了剩余的查询可以在当前节点所在的长链上完成。
##### 完整代码
```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
using namespace std;

#define ui unsigned int
ui s;

inline ui get(ui x) 
{
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    return s = x; 
}

int cnt, lgn;
vector<vector<int>> st, adj; // st:倍增祖先, adj:邻接表
vector<int> fa, dep, son, len; // fa:父节点, dep:深度, son:长儿子, len:以该节点为根的子树中的最大深度
vector<int> top, dfn, up, down; // top:链顶, dfn:dfs序, up/down:预处理数组

// 初始化函数
void init(int n)
{
    cnt = 0; // dfs序 计数器
    lgn = log2(n) + 1; // 倍增数组第二维的大小
    fa.resize(n + 1);
    dep.resize(n + 1);
    son.resize(n + 1);
    len.resize(n + 1);
    top.resize(n + 1);
    dfn.resize(n + 1);
    
    adj.resize(n + 1);
    up.resize(n + 1);
    down.resize(n + 1);
    st.assign(n + 1, vector<int>(lgn + 1, 0));
}

// 第一次DFS：处理深度、父亲、倍增祖先、子树最大深度(len)和长儿子(son)
void dfs1(int u, int f)
{
    st[u][0] = f; // u的直接父亲
    // 预处理倍增数组
    for (int i = 1; i <= lgn; i ++)
        st[u][i] = st[st[u][i - 1]][i - 1];

    dep[u] = dep[f] + 1; // 计算深度
    for (auto v : adj[u])
    {
        if (v == f)
            continue;
        dfs1(v, u);
        // 更新长儿子：如果v的len比当前记录的son[u]的len要大，则更新son[u]为v
        if (len[v] > len[son[u]])
            son[u] = v;
    }
    // 计算u的len，等于其长儿子的len + 1
    len[u] = len[son[u]] + 1;
}

// 第二次DFS：处理每条长链的 链顶(top) 和 dfs序(dfn)
void dfs2(int u, int t)
{
    top[u] = t; // 设置 u 所在长链的链顶
    dfn[u] = ++ cnt; // 分配 dfs序
    // 如果没有儿子，说明是叶子节点，返回
    if (!son[u])
        return;
    // 优先递归长儿子，保证长链上的 dfs序 是连续的
    dfs2(son[u], t); 
    
    // 递归处理其他轻儿子
    for (auto v : adj[u])
    {
        // 排除父亲和长儿子
        if (v == fa[u] || v == son[u])
            continue;
        // 轻儿子是新长链的链顶，所以第二个参数传 v 自己
        dfs2(v, v);
    }
}

void solve()
{
    int n, q, r;
    cin >> n >> q >> s;
    init(n);
    // 读入父亲节点，建树
    for (int i = 1; i <= n; i ++)
    {
        cin >> fa[i];
        if (!fa[i]) r = i; // fa[i]为 0 的是根节点
        else
        {
            // 建立双向边
            adj[i].emplace_back(fa[i]);
            adj[fa[i]].emplace_back(i);
        }
    }
    
    // 预处理
    dfs1(r, 0);
    dfs2(r, r);
    
    // 对每条长链进行预处理，填充 up 和 down 数组
    for (int u = 1; u <= n; u ++)
    {
        // 只对每条长链的链顶进行一次预处理
        if (u == top[u]) 
        {
            // a 指针向上移动，b 指针向下移动
            for (int j = 0, a = u, b = u; j < len[u]; j ++, a = st[a][0], b = son[b])
            {
                // dfn[u] + j 位置存储向上 j 步的祖先
                up[dfn[u] + j] = a; 
                // dfn[u] + j 位置存储向下 j 步的儿子
                down[dfn[u] + j] = b;
            }
        }
    }

    int pre = 0; // 上一次查询的答案
    long long ans = 0;
    for (int i = 1; i <= q; i ++)
    {
        // 根据题目要求生成查询的节点 x 和距离 k
        int x = ((get(s) ^ pre) % n) + 1;
        int k = (get(s) ^ pre) % dep[x];
        
        // k = 0时，祖先就是自己
        if (k == 0) pre = x;
        else
        {
            // 核心查询逻辑
            // 1. 找到小于等于 k 的 最大2的次幂，用 __builtin_clz 快速计算 log2(k)
            int clz = 31 - __builtin_clz(k);
            // 2. 利用倍增数组先跳一大步，到达cur节点
            int cur = st[x][clz];
            // 3. 找到cur所在长链的链顶tp
            int tp = top[cur];
            // 4. 计算剩余需要跳的步数
            k -= 1 << clz; // 减去倍增跳过的距离
            k -= dep[cur] - dep[tp]; // 减去从cur到链顶tp的距离
            
            // 5. O(1)查询
            // 如果k >= 0，说明目标祖先在 tp 或 tp 的上方。从 tp 向上走 k 步。
            // 访问 up 数组的位置是 dfn[tp] + k
            if (k >= 0) pre = up[dfn[tp] + k];
            // 如果k < 0，说明目标祖先在 cur 和 tp 之间。从 tp 向下走 -k 步。
            // 访问 down 数组的位置是 dfn[tp] - k
            else pre = down[dfn[tp] - k];
        }
        ans ^= 1ll * i * pre;
    }
	print("{}", ans);
}

int main()
{
    IOS;
    solve();
    return 0;
}
```
#### 长链剖分优化技巧
##### 优化DP
长链剖分是优化一类树形DP的利器，这类DP的状态转移通常与节点的深度有关。

**适用场景**:
DP状态中有一维是子树的深度，例如 $dp[u][j]$ 表示在节点 `u` 的子树中，距离 `u` 为 `j` 的节点的某种信息（如数量、权值和等）。
**核心思想**:
在树上进行DFS，计算每个节点的DP值。对于节点 `u`，我们先递归处理它的所有儿子 `v`。
1.  **继承长儿子信息**：对于 `u` 的长儿子 `son[u]`，我们不为其开辟新的DP数组空间。而是通过指针或数组偏移的方式，让 `u` 直接“继承”`son[u]` 的DP数组。因为 `u` 到它子树中最深节点的路径必然经过 `son[u]`，所以 $dp[u][j]$ 对应于 $dp[son[u]][j-1]$。这种继承是 $O(1)$ 的。
2.  **合并短儿子信息**：对于 `u` 的其他短儿子 `v`，它们的信息不能直接继承。我们需要暴力递归计算它们的DP值，然后将这些信息合并到 `u` 的DP数组中。合并时，遍历短儿子 `v` 的DP数组，用 $dp[v][j]$ 来更新 $dp[u][j+1]$。
3.  **更新自身信息**：最后，根据节点 `u` 自身的属性，更新 $dp[u][0]$。

**复杂度分析**:
为什么这样能优化复杂度？关键在于每个节点作为“短链”的头被暴力合并的次数是有限的。
一个节点 `u` 只有当它是其父亲的短儿子时，合并它所在的子树信息才会被暴力。当一个节点被暴力合并时，它会向上走到它所在长链的链顶，然后它所在的这条长链会并入一条更长的链中。
每个节点一生只会被作为短链合并一次。在合并时，我们遍历的复杂度取决于短链的长度。
所有短链的长度之和是 $O(n)$ 的（因为所有长链的长度之和最大为 $n$，而所有边的总数是 $n-1$）。
因此，总的时间复杂度可以从朴素的 $O(n^2)$ 优化到 $O(n)$。
##### 优化贪心
虽然“优化贪心”这个提法不常见，但其本质与优化DP类似，通常应用于解决一些需要合并子树信息的树上问题，这些问题可以用贪心策略解决，并且信息的合并与深度有关。

**适用场景**:
问题需要在子树间合并某种“最优化”的、与深度相关的选择。例如，在子树中选择一些节点，使得满足某种约束条件，同时最大化/最小化某个目标，且选择策略依赖于到当前子树根节点的距离。
**核心思想**:
与优化DP类似，我们将子树信息（通常是关于不同深度的最优解或状态）存储起来。
1.  **优先处理长儿子**：首先递归解决长儿子 `son[u]` 的问题。
2.  **信息继承**：将长儿子的解作为当前节点 `u` 的初始解。这通常意味着将 `son[u]` 的信息（比如一个存储了各深度最优选择的数组/map）直接拿过来用，深度整体加 $1$。这个过程通过指针或引用传递，是 $O(1)$ 的。
3.  **合并短儿子**：然后，依次处理 `u` 的其他短儿子 `v`。暴力计算出 `v` 的解，然后将 `v` 子树的解（贪心选择）合并到 `u` 当前的解中。合并过程可能需要更新 `u` 在各个深度的最优选择。
4.  **处理当前节点**：最后，考虑节点 `u` 自身，看是否要将其加入选择，并更新最终的解。

这里的“优化”体现在，通过长链剖分，我们避免了对长儿子信息的复制和重复计算，只对短儿子的信息进行暴力合并，从而将总复杂度控制在 $O(n \log n)$（如果用 `map`）或 $O(n)$（如果用数组+指针）。
## 可持久化数据结构 (Persistent Data Structures)
**可持久化**的核心思想是，能够**保留数据结构的每一个历史版本**，并支持对任意历史版本进行**访问**、以及**以任意历史版本为基础创建新版本**
这里的关键在于“**创建新版本**”，而不是“修改”或“覆写”一个已经存在的历史版本，旧版本一旦被创建，它就是**不可变** 的

如果我们每次操作都**完整地复制**一遍整个数据结构，那么空间和时间开销都将是巨大的，通常无法接受，因此，对于树形数据结构（如线段树），我们采用**路径复制** 的策略：
- **访问**操作不改变结构，可以直接进行
- **创建新版本**时，我们**不修改原有的节点**，而是**只为从根节点到被修改位置的路径上的所有节点，创建新的副本**
- 新节点中，指向**未被修改**的分支的指针，可以直接**指向旧版本的对应节点**，从而**共享**大部分未发生变化的数据
- 每次操作都会生成一个新的根节点，代表一个新的版本，我们将这些根节点按顺序保存起来，即可随时访问任意版本

通过这种方式，每次修改操作只需要新建 **$\mathcal O(\log n)$** 个节点，极大地节省了时间和空间
### 版本模型区别
1.  **树形版本模型 (如 可持久化数组)**：任何旧版本 `v` 都可以“分叉”出一个新版本 `i`
2.  **线性版本模型 (如 主席树)**：版本 `i` 严格依赖于版本 `i-1`，利用**差分**性质解决问题
### 模板例题：[P3919 可持久化数组](https://www.luogu.com.cn/problem/P3919)
维护一个数组，并支持两种操作：
1.  在**某个历史版本**上修改某一个位置的值
2.  访问**某个历史版本**上某一位置的值

每次操作都会生成一个新的版本，这正是**可持久化数组**的定义，它属于我们上面提到的**树形版本模型**，我们可以使用**可持久化线段树**来实现这个功能

我们用一个 `root` 数组来保存每个版本的根节点编号，`root[i]` 指向版本 `i` 的线段树的根

- **构建 (Build)**：我们首先对初始数组（版本 `0`）建立一棵普通的线段树，其根节点为 `root[0]`
- **修改 (Modify)**：当需要在版本 `v` 的基础上进行修改，生成新版本 `i` 时：
    1.  我们创建一个新的根节点 `root[i]`
    2.  我们从 `root[v]` 和 `root[i]` 同时开始递归
    3.  在递归过程中，对于当前节点，我们**复制**旧版本节点的信息 (`ls`, `rs`, `val`) 到新版本节点
    4.  然后判断修改位置在左子树还是右子树，并只对相应方向的子树进行**递归创建新节点**，另一方向的子树则直接**共享**旧版本的节点 (即 `ls[新] = ls[旧]`)
    5.  直到到达叶子节点，修改其值
- **查询 (Query)**：当需要查询版本 `v` 的某个值时，我们直接从 `root[v]` 开始，进行一次普通的线段树单点查询即可
#### 完整代码
```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
#define IOS ios::sync_with_stdio(0), cin.tie(0)
using namespace std;

int cnt = 0; // 节点计数器, 用于分配新节点
vector<int> arr; // 存储初始数组
vector<int> root; // root[i] 存储版本 i 的根节点编号
vector<int> ls, rs, val; // ls[u], rs[u]: 节点 u 的左右儿子编号，val[u]: 节点 u 存储的值 (本题中只有叶子节点有意义)

// 预分配内存
void init(int n, int m)
{
    // 初始建树 n, 每次修改 log n, 总共 n + m * log n
    // 空间大小需要估算, 一般开 4 * n + m * log n * k (k为常数)
    int t = 4 * n + 25 * m;
    arr.resize(n + 1);
    root.resize(m + 1); // m + 1 个版本 (0 到 m)
    ls.resize(t);
    rs.resize(t);
    val.resize(t);
}

#define mid ((l + r) >> 1)
// 构建初始版本(版本 0) 的线段树
// u: 当前节点编号, 通过引用传递, 由内部 ++ cnt 分配
void build(int &u, int l, int r)
{
    u = ++ cnt;
    if (l == r)
    {
        val[u] = arr[l];
        return;
    }
    build(ls[u], l, mid);
    build(rs[u], mid + 1, r);
}

// 修改操作, 生成一个新版本
// u: 新版本要创建的节点 (引用传递), v: 所基于的旧版本的节点
// jobp, jobv: 要修改的位置和值
void modify(int &u, int v, int jobp, int jobv, int l, int r)
{
    u = ++ cnt; // 为新路径上的节点分配编号
    // 复制旧节点信息, 共享未修改的分支
    ls[u] = ls[v], rs[u] = rs[v], val[u] = val[v];
    if (l == r)
    {
        val[u] = jobv;
        return;
    }
    // 根据修改位置, 递归进入对应分支创建新节点
    if (jobp <= mid) modify(ls[u], ls[v], jobp, jobv, l, mid);
    else modify(rs[u], rs[v], jobp, jobv, mid + 1, r);
}

// 查询操作, 在指定版本上查询
int query(int u, int jobp, int l, int r) // u: 要查询的版本的根节点
{
    if (l == r) return val[u];
    if (jobp <= mid) return query(ls[u], jobp, l, mid);
    else return query(rs[u], jobp, mid + 1, r);
}
#undef mid

void solve()
{
    int n, m;
    cin >> n >> m;
    init(n, m);
    for (int i = 1; i <= n; i ++)
        cin >> arr[i];
    // 构建版本 0
    build(root[0], 1, n);

    int v, op, p, c;
    for (int i = 1; i <= m; i ++)
    {
        cin >> v >> op;
        if (op == 1)
        {
            cin >> p >> c;
            // 在版本 v 的基础上修改, 生成新版本 i
            modify(root[i], root[v], p, c, 1, n);
        }
        else if (op == 2)
        {
            cin >> p;
            // 查询也生成一个新版本, 该版本与被查询的版本完全一样
            root[i] = root[v];
            println("{}", query(root[v], p, 1, n));
        }
    }
}

int main()
{
    IOS;
    solve();
    return 0;
}
```
### 模板例题：[P3834 主席树](https://www.luogu.com.cn/problem/P3834)

给定 $n$ 个整数构成的序列 $a$。
每次询问，对于指定的闭区间 $[l,r]$ 查询其区间内的第 $k$ 小值。

这道题要求查询**静态区间第 k 小**，是**主席树**的经典应用，它属于我们上面提到的**线性版本模型**
主席树，本质上是**可持久化的权值线段树**，它通过巧妙的构造，利用区间的**前缀和**思想来解决查询问题

1.  **离散化**：由于原数值范围很大，但数量不多，我们首先对所有数进行**离散化**，将它们映射到 `[1, T]` 的一个较小区间内，其中 `T` 是不同数值的个数
2.  **权值线段树**：我们建立的线段树不再是基于数组下标，而是基于**值的范围 (即离散化后的 `[1, T]`)**，树中每个节点 `u` 的 `val[u]` 存储的是**某个数在某个范围内出现的次数**
3.  **构建 `n` 个线性版本**：我们遍历原数组 `a`，对每个 `a[i]` 建立一个版本，总共 `n` 个版本
    -   版本 `i` 的线段树 (`root[i]`) 存储的是原数组**前缀 `a[1...i]`** 中，各个数值出现的次数
    -   `root[i]` 是在 `root[i-1]` 的基础上，只**修改**与 `a[i]` 的值对应的路径而产生的，具体操作是在代表 `a[i]` 离散化后值的那个叶子节点上，将计数 `+1`
4.  **利用前缀和思想查询**：
    -   查询区间 `[l, r]` 的第 `k` 小，等价于查询**版本 `r`** 和**版本 `l-1`** 这两棵树的差异
    -   `root[r]` 存储了 `a[1...r]` 的信息，`root[l-1]` 存储了 `a[1...l-1]` 的信息，那么 `root[r]` 对应节点的值减去 `root[l-1]` 对应节点的值，就得到了 `a[l...r]` 区间内各个数值的出现次数
    -   我们从 `root[r]` 和 `root[l-1]` 同时开始遍历，设当前左右子树在 `[l, r]` 区间内的数的个数差为 `t` (`t = val[ls[root[r]]] - val[ls[root[l-1]]]`)
    -   如果 `k <= t`，说明第 `k` 小的数落在左子树代表的值域内，我们向左子树递归
    -   否则，说明第 `k` 小的数在右子树，我们向右子树递归，并查询第 `k - t` 小
#### 完整代码
```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
#define IOS ios::sync_with_stdio(0), cin.tie(0)
using namespace std;

int n, t, cnt = 0; // n: 数组长度, t: 离散化后不同值的个数
vector<int> root; // root[i] 存储版本 i 的根
vector<int> ls, rs, val; // ls, rs: 左右儿子; val: 节点代表值域区间内数的个数

// 预分配内存
void init(int n)
{
    // 每个版本新建 log(T) 个节点, T 最大为 n
    int m = 25 * n; 
    root.resize(n + 1);
    ls.resize(m);
    rs.resize(m);
    val.resize(m);
}
// 向上更新节点信息
void push_up(int u) { val[u] = val[ls[u]] + val[rs[u]]; }

#define mid ((l + r) >> 1)
// 修改操作, 也是构建新版本的过程
// u: 新版本节点, v: 旧版本节点, jobp: 要修改的值(离散化后)
void modify(int &u, int v, int jobp, int jobv, int l, int r)
{
    u = ++ cnt;
    ls[u] = ls[v], rs[u] = rs[v], val[u] = val[v];
    if (l == r)
    {
        val[u] += jobv; // 叶子节点计数增加
        return;
    }
    if (jobp <= mid) modify(ls[u], ls[v], jobp, jobv, l, mid);
    else modify(rs[u], rs[v], jobp, jobv, mid + 1, r);
    push_up(u); // 回溯时更新路径上节点的计数值
}
// 查询区间第 k 小
// u: root[l-1], v: root[r], k: 要查询的第 k 小, l, r: 当前节点代表的值域区间
int query(int u, int v, int k, int l, int r)
{
    if (l == r) return l; // 找到叶子节点, 返回离散化后的值
    // 计算左子树在 [l, r] 区间内的元素个数
    int t = val[ls[v]] - val[ls[u]];
    if (k <= t) // 第 k 小在左子树
        return query(ls[u], ls[v], k, l, mid);
    else // 第 k 小在右子树
        return query(rs[u], rs[v], k - t, mid + 1, r);
}
#undef mid

void solve()
{
    int n, m;
    cin >> n >> m;
    vector<int> v(n + 1);
    for (int i = 1; i <= n; i ++)
        cin >> v[i];

    // --- 离散化 ---
    auto rnk = v;
    sort(rnk.begin() + 1, rnk.end());
    rnk.erase(unique(rnk.begin() + 1, rnk.end()), rnk.end());
    // 获取 x 离散化后的排名
    auto getRank = [&](int x) -> int { return lower_bound(rnk.begin() + 1, rnk.end(), x) - rnk.begin(); };

    // t 是离散化后不同数值的总数
    int t = rnk.size() - 1;
    init(n);
    // 构建 1 到 n 共 n 个版本的主席树
    for (int i = 1; i <= n; i ++) // root[i] 在 root[i-1] 的基础上, 插入第 i 个数
        modify(root[i], root[i - 1], getRank(v[i]), 1, 1, t);
    
    for (int i = 1, l, r, k; i <= m; i ++)
    {
        cin >> l >> r >> k;
        // 在版本 r 和版本 l-1 的差分树上查询第 k 小
        // 结果是离散化后的排名, 需要用 rnk 数组映射回原值
        println("{}", rnk[query(root[l - 1], root[r], k, 1, t)]);
    }
}

int main()
{
    IOS;
    solve();
    return 0;
}
```