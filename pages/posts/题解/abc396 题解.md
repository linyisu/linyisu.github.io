---
title: abc-396 题解
math: true
  - 比赛 题解
date: 2025-03-10 01:23:17
cover: https://ooo.0x0.ooo/2025/08/22/OfdYEF.jpg
tags:
---

## **A - Triple Four**

## 题目描述

给定一个长度为 $N$ 的整数序列 $A = (A_1, A_2, \ldots, A_N)$。

请判断 $A$ 中是否存在连续三个及以上相同元素的片段。  
更严格地说，请判断是否存在满足 $1 \leq i \leq N-2$ 的整数 $i$，使得 $A_i = A_{i+1} = A_{i+2}$。

## 输入格式

输入通过标准输入给出，格式如下：

> $N$ $A_1$ $A_2$ $\ldots$ $A_N$

## 输出格式

若 $A$ 中存在连续三个及以上相同元素的片段，输出 `Yes`；否则输出 `No`。

## 输入输出样例 #1

### 输入 #1

```
5
1 4 4 4 2
```

### 输出 #1

```
Yes
```

## 输入输出样例 #2

### 输入 #2

```
6
2 4 4 2 2 4
```

### 输出 #2

```
No
```

## 输入输出样例 #3

### 输入 #3

```
8
1 4 2 5 7 7 7 2
```

### 输出 #3

```
Yes
```

## 输入输出样例 #4

### 输入 #4

```
10
1 2 3 4 5 6 7 8 9 10
```

### 输出 #4

```
No
```

## 输入输出样例 #5

### 输入 #5

```
13
1 1 1 1 1 1 1 1 1 1 1 1 1
```

### 输出 #5

```
Yes
```

## 说明/提示

### 约束条件

- $3 \leq N \leq 100$
- $1 \leq A_i \leq 100$
- 输入中的所有值均为整数

### 样例解释 1

$A = (1, 4, 4, 4, 2)$ 中存在三个连续的 $4$，因此输出 `Yes`。

### 样例解释 2

$A = (2, 4, 4, 2, 2, 4)$ 中没有连续三个及以上相同元素的片段，因此输出 `No`。


### 大意

给定长度为 `n` 的序列，回答是否存在一个数，在该序列中连续出现至少三次。

暴力，（不知道为啥给那么多样例…）

### CODE

```cpp
void solve()
{
    int n;  cin >> n;
    vector<int> v(n);
    for (auto &x : v)   cin >> x;
    bool flag = false;
    for (int i = 0; i + 2 < n; i ++)
        if (v[i] == v[i + 1] && v[i + 1] == v[i + 2])
            flag = true;
    cout << (flag ? "Yes" : "No") << _endl;
}
```

## **B - Card Pile**

## 题目描述

存在一个初始由 $100$ 张写有整数 $0$ 的卡片堆叠而成的卡堆。

请处理 $Q$ 个查询。每个查询为以下两种类型之一：

- 类型 $1$：将一张写有整数 $x$ 的卡片放到卡堆的最上方。
- 类型 $2$：移除卡堆最上方的卡片，并输出被移除卡片上的整数。在本问题的约束下，保证此时卡堆中必定存在卡片。

## 输入格式

输入通过标准输入给出，格式如下：

> $Q$  
> $\text{query}_1$  
> $\text{query}_2$  
> $\vdots$  
> $\text{query}_Q$

在第 $i$ 个查询 $\text{query}_i$ 中，首先给出查询类型 $c_i$（取值为 $1$ 或 $2$）。当 $c_i = 1$ 时，还会额外给出一个整数 $x$。

即，每个查询为以下两种格式之一：

> $1$ $x$

> $2$

## 输出格式

设满足 $c_i = 2$ 的查询共有 $q$ 次，请输出 $q$ 行。  
第 $j$ 行（$1 \leq j \leq q$）输出第 $j$ 次此类查询对应的结果。

## 输入输出样例 #1

### 输入 #1

```
6
2
1 4
1 3
2
2
2
```

### 输出 #1

```
0
3
4
0
```

## 输入输出样例 #2

### 输入 #2

```
5
2
2
2
2
2
```

### 输出 #2

```
0
0
0
0
0
```

## 说明/提示

### 约束条件

- $1 \leq Q \leq 100$
- $1 \leq x \leq 100$
- 保证至少存在一个类型 $2$ 的查询。
- 输入中的所有值均为整数

### 样例解释 1

各查询处理后的卡堆状态如下（按顺序）：
- 移除卡堆最上方的卡片。被移除卡片上的整数为 $0$，因此输出 $0$。
- 卡堆变为 $99$ 张写有 $0$ 的卡片。
- 将写有 $4$ 的卡片放到卡堆最上方。
- 卡堆变为：最上方 $1$ 张写有 $4$ 的卡片，下方 $99$ 张写有 $0$ 的卡片。
- 将写有 $3$ 的卡片放到卡堆最上方。
- 卡堆变为：最上方 $1$ 张写有 $3$ 的卡片，中间 $1$ 张写有 $4$ 的卡片，下方 $99$ 张写有 $0$ 的卡片。
- 移除卡堆最上方的卡片。被移除卡片上的整数为 $3$，因此输出 $3$。
- 卡堆变为：最上方 $1$ 张写有 $4$ 的卡片，下方 $99$ 张写有 $0$ 的卡片。
- 移除卡堆最上方的卡片。被移除卡片上的整数为 $4$，因此输出 $4$。
- 卡堆变为 $99$ 张写有 $0$ 的卡片。
- 移除卡堆最上方的卡片。被移除卡片上的整数为 $0$，因此输出 $0$。
- 卡堆变为 $98$ 张写有 $0$ 的卡片。


### 大意

给一个牌堆（栈），初始时，牌堆中有一百张标号为`0`的牌，给定 `q` 个询问，对于每个询问，若是类型`1`则将标号为 `x` 的牌放到牌堆顶，

若是类型`2`则取出牌堆顶的牌，并输出其标号。

模拟，可使用 `stack` 或数组模拟栈。

### CODE

```cpp
void solve()
{
    stack<int> st;
    for (int i = 1; i <= 100; i ++)
        st.push(0);
    int n, op, x;  cin >> n;
    for (int i = 1; i <= n ; i ++)
    {
        cin >> op;
        if (op == 1)
            cin >> x, st.push(x);
        else if (op == 2)
            cout << st.top() << "\n", st.pop();
    }
}
```

## **C - Buy Balls**

## 题目描述

现有 $N$ 个黑色球和 $M$ 个白色球。  
每个球都有一个价值：第 $i$ 个（$1 \leq i \leq N$）黑色球的价值为 $B_i$，第 $j$ 个（$1 \leq j \leq M$）白色球的价值为 $W_j$。

请选择 **零个或多个** 球，使得所选黑色球的数量 **不少于** 白色球的数量。求所选球的价值总和的最大可能值。

## 输入格式

输入通过标准输入给出，格式如下：

> $N$ $M$  
> $B_1$ $B_2$ $\ldots$ $B_N$  
> $W_1$ $W_2$ $\ldots$ $W_M$

## 输出格式

输出答案。

## 输入输出样例 #1

### 输入 #1

```
4 3
8 5 -1 3
3 -2 -4
```

### 输出 #1

```
19
```

## 输入输出样例 #2

### 输入 #2

```
4 3
5 -10 -2 -5
8 1 4
```

### 输出 #2

```
15
```

## 输入输出样例 #3

### 输入 #3

```
3 5
-36 -33 -31
12 12 28 24 27
```

### 输出 #3

```
0
```

## 说明/提示

### 约束条件

- $1 \leq N, M \leq 2 \times 10^5$
- $-10^9 \leq B_i, W_j \leq 10^9$
- 输入中的所有值均为整数

### 样例解释 1

选择第 $1,2,4$ 个黑色球和第 $1$ 个白色球时，总价值为 $8 + 5 + 3 + 3 = 19$，这是最大值。

### 样例解释 2

选择第 $1,3$ 个黑色球和第 $1,3$ 个白色球时，总价值为 $5 + (-2) + 8 + 4 = 15$，这是最大值。

### 样例解释 3

允许不选择任何球，此时总价值为 $0$。

### 大意

给定两个序列，长度分别为 `n, m` , 表示存在 `n` 个黑球和 `m` 个白球，每个球都有一个权值，回答在满足 选择的黑球数 $\geq$ 白球数 的条件下，所有被选球权值的最大值。

对两个序列分别降序排序， 找到白球选择的数量 `k` , 再判断黑球是否可以继续选择更多。

### CODE

```cpp
void solve()
{
    int n, m;   cin >> n >> m;
    vector<int> b(n), w(m);
    for (auto &x : b)   cin >> x;
    for (auto &x : w)   cin >> x;
    sort(b.begin(), b.end(), greater<int>());
    sort(w.begin(), w.end(), greater<int>());
    int ans = 0, i;
    for (i = 0; i < min(m, n); i ++)
    {
        if (b[i] >= w[i] && b[i] >= 0 && w[i] >= 0)
            ans += b[i] + w[i];
        else if (b[i] < w[i] && b[i] + w[i] > 0) ans += b[i] + w[i];   
        else break;
    }
    for (; i < n; i ++) 
        ans += (b[i] > 0 ? b[i] : 0);
    cout << ans;
}
```

## **D - Minimum XOR Path**

## 题目描述

给定一个简单连通无向图，包含 $N$ 个顶点（编号为 $1$ 至 $N$）和 $M$ 条边（编号为 $1$ 至 $M$）。边 $i$ 连接顶点 $u_i$ 和 $v_i$，并带有标签 $w_i$。

请找出从顶点 $1$ 到顶点 $N$ 的所有简单路径（不重复经过顶点的路径）中，路径上所有边标签的总异或值的最小可能值。

关于异或（XOR）的定义：  
对于非负整数 $A$ 和 $B$，它们的异或 $A \oplus B$ 定义如下：
- $A \oplus B$ 的二进制表示中，$2^k$ 位（$k \geq 0$）的值为 $1$，当且仅当 $A$ 和 $B$ 在 $2^k$ 位上的值不同；否则为 $0$。

例如，$3 \oplus 5 = 6$（二进制表示为 $011 \oplus 101 = 110$）。  
对于 $k$ 个整数 $p_1, \dots, p_k$ 的异或，定义为 $(\cdots ((p_1 \oplus p_2) \oplus p_3) \oplus \cdots \oplus p_k)$，且其值与运算顺序无关。

## 输入格式

输入通过标准输入给出，格式如下：

> $N$ $M$  
> $u_1$ $v_1$ $w_1$  
> $u_2$ $v_2$ $w_2$  
> $\vdots$  
> $u_M$ $v_M$ $w_M$

## 输出格式

输出答案。

## 输入输出样例 #1

### 输入 #1

```
4 4
1 2 3
2 4 5
1 3 4
3 4 7
```

### 输出 #1

```
3
```

## 输入输出样例 #2

### 输入 #2

```
4 3
1 2 1
2 3 2
3 4 4
```

### 输出 #2

```
7
```

## 输入输出样例 #3

### 输入 #3

```
7 10
1 2 726259430069220777
1 4 988687862609183408
1 5 298079271598409137
1 6 920499328385871537
1 7 763940148194103497
2 4 382710956291350101
3 4 770341659133285654
3 5 422036395078103425
3 6 472678770470637382
5 7 938201660808593198
```

### 输出 #3

```
186751192333709144
```

## 说明/提示

### 约束条件

- $2 \leq N \leq 10$
- $N - 1 \leq M \leq \frac{N(N-1)}{2}$
- $1 \leq u_i < v_i \leq N$
- $0 \leq w_i < 2^{60}$
- 输入的图是简单连通无向图
- 输入中的所有值均为整数

### 样例解释 1

从顶点 $1$ 到顶点 $4$ 存在以下两条简单路径：  
1. 顶点 $1$ → 顶点 $2$ → 顶点 $4$  
   路径上的边标签总异或值为 $6$。  
2. 顶点 $1$ → 顶点 $3$ → 顶点 $4$  
   路径上的边标签总异或值为 $3$。  
因此，最小值为 $3$。

### 大意

给定一个 `n` 个点， `m` 条边的简单无向图，每条边存在一个权值。找到从 $1 \sim N$ 的简单路径中，边权异或和最小的路径，输出该异或和。

观察到 $n \in [2,\ 10]$ ， 可直接暴力 `dfs` 。

需注意是无向图， （因为赛时没看到，卡了好久……）。

### CODE

```cpp
void solve()
{
    int n, m;   cin >> n >> m;
    vector<vector<pair<int, int>>> adj(n + 1);
    for (int i = 1; i <= m; i ++)
    {
        int u, v, w;    
        cin >> u >> v >> w;
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }

    int ans = inf;
    vector<int> vis(n + 1, false);
    auto dfs = [&](auto self, int s, int Xor) -> void
    {
        if (s == n)
        {
            ans = min(ans, Xor);
            return;
        }
        for (auto [son, val] : adj[s])
            if (!vis[son])
            {
                vis[son] = true;
                self(self, son, Xor ^ val);
                vis[son] = false;
            }
    };

    vis[1] = true;
    dfs(dfs, 1, 0);
    cout << ans;
}
```

## **E - Min of Restricted Sum**

## 题目描述

给定整数 $N, M$ 和长度为 $M$ 的整数序列 $X=(X_1,X_2,\ldots,X_M)$、$Y=(Y_1,Y_2,\ldots,Y_M)$、$Z=(Z_1,Z_2,\ldots,Z_M)$。其中，保证 $X$ 和 $Y$ 的所有元素均在 $1$ 至 $N$ 的范围内。

定义长度为 $N$ 的非负整数序列 $A=(A_1,A_2,\ldots,A_N)$ 为 **好的整数序列**，当且仅当满足以下条件：
- 对于所有满足 $1 \leq i \leq M$ 的整数 $i$，有 $A_{X_i} \oplus A_{Y_i} = Z_i$，其中 $\oplus$ 表示异或运算。

请判断是否存在这样的好的整数序列。若存在，请找出使得元素总和 $\displaystyle \sum_{i=1}^N A_i$ 最小的好的整数序列，并输出该序列。

关于异或（XOR）的定义：  
对于非负整数 $A$ 和 $B$，它们的异或 $A \oplus B$ 定义如下：
- $A \oplus B$ 的二进制表示中，$2^k$ 位（$k \geq 0$）的值为 $1$，当且仅当 $A$ 和 $B$ 在 $2^k$ 位上的值不同；否则为 $0$。

例如，$3 \oplus 5 = 6$（二进制表示为 $011 \oplus 101 = 110$）。

## 输入格式

输入通过标准输入给出，格式如下：

> $N$ $M$  
> $X_1$ $Y_1$ $Z_1$  
> $X_2$ $Y_2$ $Z_2$  
> $\vdots$  
> $X_M$ $Y_M$ $Z_M$

## 输出格式

若不存在好的整数序列，输出 $-1$。  
若存在，则输出满足总和最小的好的整数序列，元素间用空格分隔。  
若存在多个总和最小的序列，输出任意一个均可。

## 输入输出样例 #1

### 输入 #1

```
3 2
1 3 4
1 2 3
```

### 输出 #1

```
0 3 4
```

## 输入输出样例 #2

### 输入 #2

```
3 3
1 3 4
1 2 3
2 3 5
```

### 输出 #2

```
-1
```

## 输入输出样例 #3

### 输入 #3

```
5 8
4 2 4
2 3 11
3 4 15
4 5 6
3 2 11
3 3 0
3 1 9
3 4 15
```

### 输出 #3

```
0 2 9 6 0
```

## 说明/提示

### 约束条件

- $1 \leq N \leq 2 \times 10^5$
- $0 \leq M \leq 10^5$
- $1 \leq X_i, Y_i \leq N$
- $0 \leq Z_i \leq 10^9$
- 输入中的所有值均为整数

### 样例解释 1

序列 $A=(0, 3, 4)$ 满足 $A_1 \oplus A_2 = 3$ 和 $A_1 \oplus A_3 = 4$，因此是好的整数序列。其他可能的序列如 $A=(1, 2, 5)$ 或 $A=(7, 4, 3)$ 也满足条件，但总和最小的序列是 $A=(0, 3, 4)$。

### 样例解释 2

不存在满足条件的好的整数序列，因此输出 $-1$。

### 大意

给定三个长度为 `m` 的序列 $X = (X_1, X_2, \ldots, X_M)$, $Y = (Y_1, Y_2, \ldots, Y_M)$, 和 $Z = (Z_1, Z_2, \ldots, Z_M)$. 

要求构造出一个长度为 `$n$` 的序列 $A=(A_1,A_2,\ldots,A_N)$ , 使得 对于所有 $i \in [1, m]$ , 都有 $A_{X_i} \oplus A_{Y_i} = Z_i$ .


## **F - Rotated Inversions**

## 题目描述

给定整数 $N, M$ 和一个长度为 $N$ 的非负整数序列 $A=(A_1, A_2, \ldots, A_N)$。

对于每个 $k=0,1,\ldots,M-1$，请解决以下问题：

> 定义整数序列 $B=(B_1, B_2, \ldots, B_N)$，其中 $B_i = (A_i + k) \bmod M$。求序列 $B$ 的逆序对数。

关于逆序对数的定义：  
序列 $(A_1, A_2, \ldots, A_N)$ 的逆序对数是指满足 $1 \leq i < j \leq N$ 且 $A_i > A_j$ 的整数对 $(i, j)$ 的个数。

## 输入格式

输入通过标准输入给出，格式如下：

> $N$ $M$  
> $A_1$ $A_2$ $\ldots$ $A_N$

## 输出格式

输出共 $M$ 行。  
第 $i$ 行（$1 \leq i \leq M$）应输出 $k = i - 1$ 时的答案。

## 输入输出样例 #1

### 输入 #1

```
3 3
2 1 0
```

### 输出 #1

```
3
1
1
```

## 输入输出样例 #2

### 输入 #2

```
5 6
5 3 5 0 1
```

### 输出 #2

```
7
3
3
1
1
5
```

## 输入输出样例 #3

### 输入 #3

```
7 7
0 1 2 3 4 5 6
```

### 输出 #3

```
0
6
10
12
12
10
6
```

## 说明/提示

### 约束条件

- $1 \leq N, M \leq 2 \times 10^5$
- $0 \leq A_i < M$
- 输入中的所有值均为整数

### 样例解释 1

- 当 $k=0$ 时：$B=(2, 1, 0)$，逆序对数为 $3$（所有 $(i,j)$ 对均满足条件）。
- 当 $k=1$ 时：$B=(0, 2, 1)$，逆序对数为 $1$（仅 $(2,3)$ 满足）。
- 当 $k=2$ 时：$B=(1, 0, 2)$，逆序对数为 $1$（仅 $(1,2)$ 满足）。

### 大意

给定两个整数 $N, M$ , 和一个长度为 `N` 的序列 $A = (A_1, A_2, \ldots, A_N)$.

定义一次转变为使得 $B_i = (A_i + k) \bmod M$.

对于 $k \in [0, M-1]$ , 分别依次输出每次转变生成的序列 `B` 的逆序对数。

### 思路

可先用 **[归并排序 / 树状数组 / 线段树](https://linyisu.github.io/2025/02/04/%E9%80%86%E5%BA%8F%E5%AF%B9/)** 求得原给定序列 $A$ 的逆序对数。

再次观察每次的转变，以 Sample Input 2 为例：

```
5 3 5 0 1 
0 4 0 1 2 
1 5 1 2 3 
2 0 2 3 4 
3 1 3 4 5 
4 2 4 5 0 
```

可以发现， 在除了 以 $B_i$ 由 $M-1$ 变为 $0$ 组成的数对外，其余数对的相对大小是不变的，例如下面加粗的每行三个数组成的三组数对 $(3,\ 0), (3,\ 1), (0,\ 1)$ 变成了 $(4,\ 1), (4,\ 2), (1,\ 2)$ ，逆序对数依旧是两对。

5 **3** 5 **0** **1** 
0 **4** 0 **1** **2** 

根据**贡献法**，只有当  $B_i$ 由 $M-1$ 变为 $0$ ，其**与其左侧的每个数构成的逆序对数会增加**，**与其右侧的每个数构成的逆序对数会减少**。

且当两个数同时变小时，由于左右贡献相消，并不会导致错误。

```text
5 3 5 0 1 
先假设两个相同数对也是逆序对：
对于第一个 5 ， 其左侧没有数，不构成逆序对，其变为零后， 仍不构成逆序对； 
			  其右侧有四个数，构成四对逆序对，其变为零后， 逆序对数减少四。
对于第二个 5 ， 其左侧有两个数，构成两对逆序对，其变为零后， 逆序对数增加二。
			  其右侧有两个数，构成两对逆序对，其变为零后， 逆序对数减少二。
因此，该轮序列变化后，总逆序对数增加了 (-4 + 2 - 2) = -4 对。
而当我们考虑正常情况：
对于第一个 5 ， 其左侧没有数，不构成逆序对，其变为零后， 仍不构成逆序对； 
			  其右侧有四个数，构成三对逆序对，其变为零后， 逆序对数减少三。
对于第二个 5 ， 其左侧有两个数，构成一对逆序对，其变为零后， 逆序对数增加一。
			  其右侧有两个数，构成两对逆序对，其变为零后， 逆序对数减少二。
因此，该轮序列变化后，总逆序对数增加了 (-3 + 1 - 2) = -4 对。
```

根据上面的结论：可以想到写法，将所有答案设置为初始序列逆序对数，接下来遍历每个数，计算出其对哪几轮的变化有影响（推出在什么时候有最大值变为零），在求出它的变化的答案的贡献是多少，由于影响是区间性的（即区间修改），可以用线段树，因此就有了如下代码。

### CODE

```cpp
void solve()
{
    int n, m, prs = 0;   
    cin >> n >> m;
    vector<int> v(n + 1);
    SegTree<Info, Laz> seg(m + 1);	// 线段树就是最常见的区间加 + 区间查询
    for (int i = 1; i <= n; i ++)
    {
        cin >> v[i];    
        v[i] ++;	// 由于 v[i] 是和取模有关，存在 0 ，因此先加一，进行类似离散化操作
        prs += seg.query(v[i] + 1, m).sum;	// 查询 [v[i] + 1, +∞) 在前面的序列中出现了几次，即当前数与前面数构成的逆序对数
        seg.modify(v[i], v[i], {1});	// 当前数位置加一
        v[i] --;	// 求完逆序对后还原 v[i]
    }
    SegTree<Info, Laz> ans(m + 1);
    for (int i = 1; i <= m; i ++)
        ans.arr[i] = prs;
    ans.build();
    for (int i = 1; i <= n; i ++)	// 贡献的变化是从变化轮到最后的，属于区间修改
        ans.modify(m - v[i] + 1, m, {(i - 1) - (n - i)});	// 与其左侧的每个数构成的逆序对数会增加， 与其右侧的每个数构成的逆序对数会减少
    for (int i = 1; i <= m; i ++)
    	cout << ans.query(i, i).sum << _endl;
}
```