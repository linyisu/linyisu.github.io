---
title: SZTU_ACM新生夏令营第四次训练赛
math: true
categories:
  - 语法
  - 题解
cover: https://ooo.0x0.ooo/2025/08/22/OfdG9r.jpg
date: 2025-08-13
---

## [A - ACM中的A题](https://vjudge.net/problem/%E7%89%9B%E5%AE%A2-276055)
#### 题意
给三根木棒长 $a, b, c$，必须选择其中一根长度翻倍，判断是否能仅用修改后的三根木棒组成三角形。
#### 思路
**三角形成立条件：任意两边之和大于第三边。**  
**法一**：直接用函数判断三角形成立条件，减少排序开销。  
**法二**：枚举将哪一根木棒翻倍，**排序**后判断最短两边之和是否大于最长边。  
若任一情况满足，则输出 `Yes`，否则 `No`。
#### std
##### 法一
```cpp
#include <stdio.h>

// 判断三角形不等式
bool chk(long long a, long long b, long long c) {
    return a + b > c && a + c > b && b + c > a;
}

int main()
{
    long long a, b, c;
    scanf("%lld%lld%lld", &a, &b, &c);

    // 枚举将其中一根木棒翻倍
    if (chk(a * 2, b, c) || chk(a, b * 2, c) || chk(a, b, c * 2))
        puts("Yes"); // puts：输出字符串并自动换行
    else
        puts("No");

    return 0;
}
```
##### 法二
```cpp
#include <stdio.h>
#include <algorithm>
const int N = 3; // 木棒数量
long long a[N], b[N]; // 数组a 存原始长度，数组b 存修改后的长度

int main()
{
    // 输入三根木棒长度
    for (int i = 0; i < N; i ++)
        scanf("%lld", &a[i]);

    // 枚举将哪一根木棒长度加倍
    for (int i = 0; i < N; i ++)
    {
        // 生成当前方案的木棒长度
        for (int j = 0; j < N; j ++)
            b[j] = (j == i ? a[j] * 2 : a[j]);

        // 排序，便于判断三角形不等式
        std::sort(b, b + 3);

        // 判断能否组成三角形
        if (b[0] + b[1] > b[2])
        {
            puts("Yes"); // puts：输出字符串并自动换行
            return 0;    // 找到一种方案即可直接结束
        }
    }

    puts("No");
    return 0;
}
```
## [B - 笨蛋笨蛋笨](https://vjudge.net/problem/%E7%89%9B%E5%AE%A2-261820)
#### 题意
给定一个由 `'0'`、`'1'` 和 `'?'` 组成的字符串，求其中连续相同字符段（连续段）最大长度的可能最大值。
#### 思路
用两个变量 $(ans0, ans1)$ 分别记录当前连续“0段”和连续“1段”的长度。  
**遇 `'0'` 重置“1段”**，**遇 `'1'` 重置“0段”**，**遇 `'?'` 两者都加一**。  
遍历过程中实时更新最大连续段长度。
#### std
```cpp
#include <stdio.h>
#include <string.h>
const int N = 2e5 + 5;
char s[N];

int max(int a, int b) { return a > b ? a : b; }  // 求两个数的最大值

int main()
{
    scanf("%s", s);
    int n = strlen(s); // 获取读入字符串的长度
    int ans0 = 0, ans1 = 0, ans = 0; // ans0 记录当前连续 0段 长度，ans1 记录当前连续 1段 长度，ans 记录最大长度

    for (int i = 0; i < n; i ++)
    {
        if (s[i] == '0') 
        {
            ans0 ++;    // 遇到 '0' ，0段 长度加 1
            ans1 = 0;   // 1段 断开，重置为 0
        } 
        else if (s[i] == '1') 
        {
            ans1 ++;    // 遇到 '1' ，1段 长度加 1
            ans0 = 0;   // 0段 断开，重置为 0
        } 
        else 
        {
            ans0 ++;    // 遇到 '?' ，两种可能同时延长
            ans1 ++;
        }
        // 更新最大连续段长度
        ans = max(ans, max(ans0, ans1));
    }
    printf("%d", ans);
    return 0;
}
```
<a id="problem-C"></a>
## [C - 来！选！队！长](https://vjudge.net/problem/%E7%89%9B%E5%AE%A2-296107)
#### 题意
给定你和好友各自5个角色的战力（降序排列），判断是否存在一种你选队长的方案，使你的小队总实力（队长战力×2 + 其余四个队员战力之和）严格大于好友无论如何选队长的总实力。
#### 思路
你选最强队长，队伍总实力最大为 `sum(a) + a[0]`。  
好友选最弱队长，队伍总实力最小为 `sum(b) + b[4]`。  
若**你的最大实力**严格大于**好友的最小实力**，则输出 `YES`，否则输出 `NO`。
#### std
```cpp
#include <stdio.h>
const int N = 5;
int a[N], b[N];

int main()
{
    int sum1 = 0, sum2 = 0;
    for (int i = 0; i < N; i ++)
    {
        scanf("%d", &a[i]);  // 读入自己队伍 5 个角色的战力
        sum1 += a[i];        // 计算自己队伍战力和
    }
    for (int i = 0; i < N; i ++)
    {
        scanf("%d", &b[i]);  // 读入好友队伍 5 个角色的战力
        sum2 += b[i];        // 计算好友队伍战力和
    }
    // 判断自己最大总实力是否 严格 大于好友最小总实力，输出结果
    puts(sum1 + a[0] > sum2 + b[N - 1] ? "YES" : "NO");
    return 0;
}
```
<a id="problem-D"></a>
## [D - 二进制的梦](https://vjudge.net/problem/CodeForces-2118C)
#### 题意
给定一个长度为 `n` 的整数数组 `a` 和一个最大操作次数 `k`，每次操作可以将数组中任意一个元素加 $1$。定义一个数的 `beauty` 为其二进制表示中 $1$ 的个数，数组的 `beauty` 为所有元素 `beauty` 的和。求最多进行 `k` 次操作后，数组的最大 `beauty`。
#### 思路
每次操作只能将某个元素加 $1$，这会改变该元素的二进制表示。
当一个元素增加时，其二进制表示中的 $1$ 的数量可能增加或减少（例如，$3$($11$) 加 $1$ 变成 $4$($100$)，$1$($1$) 的数量从 $2$($10$) 减少到 $1$）。
我们的目标是**通过最多 $k$ 次加 $1$ ，使数组中所有元素的二进制表示中 $1$ 的总数最大化**。

因为 $k$ 可以高达 $10^{18}$，直接模拟每个元素的增加过程不可行。
从二进制位的角度考虑问题：对于每一位，**计算当前数组中有多少元素在该位上是 $0$**（即缺少 $1$）。
将操作视为在特定位上补充 $1$ 的过程，**补充第 $i$ 位需要 $2^i$ 次操作**（因为需要将元素从 $x$ 增加到 $x + 2^i$）。

因为**补充低位的成本更低**（$2^i$ 更小），因此选择贪心地优先在低位补充 $1$，可以用更少的操作数获得更多的 $1$。
对于每一位 $i$（从 $0$ 到 $63$）：
- 计算补充该位所有缺失 $1$ 所需的操作数：$\text{cnt}[i] \times 2^i$。
- **如果 $k \geq \text{cnt}[i] \times 2^i$，则补充该位所有缺失 $1$**，更新 $k = k - \text{cnt}[i] \times 2^i$。
- 否则，只能**部分补充**，计算可以补充的个数为 $\left\lfloor \frac{k}{2^i} \right\rfloor$，更新 $\text{cnt}[i] = \text{cnt}[i] - \left\lfloor \frac{k}{2^i} \right\rfloor$，剩余操作数 $k = k\ \%\ 2^i$，并终止补充过程。（其中， $\left\lfloor  \right\rfloor$ 为下取整符号）

初始时，数组的 `beauty` 是所有元素二进制中 $1$ 的总数。
补充过程中，**每补充一个缺失的 $1$，数组的 `beauty` 增加 $1$**。
最终的 `beauty` 是**初始 `beauty`** 加上**补充的 $1$ 的数量**。
#### std
```cpp
#include <stdio.h>
const int MAXB = 64;   // 定义最大二进制位数，因为 long long 最多 64 位
int cnt[MAXB];         // 记录每个位上缺失的 1 的数量

void solve()
{
    int n;
    long long k;
    scanf("%d%lld", &n, &k);  // 读取数组长度 n 和最大操作次数 k
    
    long long sum = 0;        // 记录初始缺失的 1 的总数
    for (int i = 0; i < MAXB; i ++)
    {
        cnt[i] = n;           // 初始化：假设所有元素在每一位都缺失
        sum += cnt[i];        // 初始化：累加初始缺失的 1 的数量
    }
    
    long long x;
    for (int i = 0; i < n; i ++)
    {
        scanf("%lld", &x);    // 读取数组元素
        for (int j = 0; j < MAXB; j ++)
        {
            // x >> j: 右移操作符，将 x 的二进制表示向右移动 j 位
            //     这样做的目的是检查 x 的第j位是否为 1
            //     例如：如果x的二进制是 1010，那么 x >> 1 的结果是 0101，x>>2 的结果是 0010
            // (x >> j) & 1: 位与操作符，将 (x >> j) 的结果与 1 进行位与运算
            //     这样做是为了检查 (x >> j) 的最低位是否为 1
            //     如果结果为 1，表示 x 的第 j 位是 1；如果结果为 0，表示 x 的第 j 位是 0
            //     例如：如果 (x >> j) 是...0101，那么与 1(...0001) 进行位与运算的结果是 1
            // 整个表达式 ((x >> j) & 1) 的功能是：检查 x 的第 j 位是否为 1
            // 如果为真，则执行 cnt[j] -- ，表示减少第 j 位的缺失计数
            if ((x >> j) & 1)
                cnt[j] --;    // 如果第 j 位为 1，则该位缺失的 1 的数量减 1
        }
    }
    
    // 贪心策略：从低位到高位补充缺失的 1
    for (int i = 0; i < MAXB; i ++)
    {
        // 计算补充第 i 位所有缺失 1 需要的操作数
        if (k >= (1ll << i) * cnt[i])
        {
            // 如果操作数足够，则补充该位所有缺失的 1
            k -= (1ll << i) * cnt[i];
            cnt[i] = 0;
        }
        else
        {
            // 如果操作数不足，则只能部分补充
            // 计算可以补充的缺失 1 的数量
            cnt[i] -= k / (1ll << i);
            // 更新剩余操作数
            k %= (1ll << i);
            // 操作数用完，退出循环
            break;
        }
    }
    
    // 计算最终补充的 1 的数量
    for (int i = 0; i < MAXB; i ++)
        sum -= cnt[i];        // 从初始缺失的 1 的总数中减去仍缺失的 1 的数量
    
    printf("%lld\n", sum);    // 输出最终的最大 beauty
}

int main()
{
    int t;
    for (scanf("%d", &t); t --; )  // 读取测试用例数量
        solve();                  // 处理每个测试用例
    return 0;
}
```
<a id="problem-E"></a>
## [E - 此方散步](https://vjudge.net/problem/CodeForces-2119B)
#### 题意
给定平面内两个点，`P` 为**起点**，`Q` 为**终点**，一个长为 `n` 的序列 `a`，第 `i` 次操作需要选一个平面内与当前点距离恰好为 $a_i$​ 的点，并走到这个点。判断 `n` 次操作后是否可以从起点**恰好**走到终点。
#### 思路
首先我们在平面上连接起点和终点，若最后可以从起点走到终点，那么这条起点到终点的边一定和 `n` 个操作所形成的边**构成一个 `n+1` 边形**。我们只需要判断这个 `n+1` 边形是否存在。
判断一个多边形的存在性可以把其类比为三角形的存在性问题上，得到：**最长边长度小于其他边长度之和**。
#### std
```cpp
#include <math.h>
#include <stdio.h>
const int N = 1e3 + 5;  // 定义数组最大大小
double a[N];            // 存储每次移动的距离

double max(double a, double b) { return a > b ? a : b; }  // 求两个数的最大值

void solve()
{
    int n;
    scanf("%d", &n);    // 读取操作次数 n
    
    int x1, y1, x2, y2;
    // 读取起点 (x1, y1) 和终点 (x2, y2) 的坐标
    scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
    
    // 读取 n 次移动的距离
    for (int i = 0; i < n; i ++)
        scanf("%lf", &a[i]);
    
    // 计算起点到终点的欧几里得距离，并存储在 a[n] 中
    // 1.0 * (x1 - x2) 确保整数运算转换为浮点数运算，同时防止爆 int
    a[n] = sqrt(1.0 * (x1 - x2) * (x1 - x2) + 1.0 * (y1 - y2) * (y1 - y2));
    
    double sum = 0, mx = 0;  // sum 存储所有距离的总和，mx 存储最大距离
    // 遍历所有距离（包括起点到终点的距离）
    for (int i = 0; i <= n; i ++)
    {
        sum += a[i];         // 累加所有距离
        mx = max(mx, a[i]);  // 更新最大距离
    }
    
    // 判断是否满足不等式：sum - mx >= mx
    // 如果满足，则可以通过一系列移动从起点到达终点
    puts(sum - mx >= mx ? "Yes" : "No");
}

int main()
{
    int t;
    // 读取测试用例数量 t
    for (scanf("%d", &t); t --; )
        solve();  // 处理每个测试用例
    return 0;
}
```
<a id="problem-F"></a>
## [F - 星星构造](https://vjudge.net/problem/CodeForces-2119C)
#### 题意
给定四个正整数 $n, l, r, k$。你需要找到长度为 $n$ 的**字典序最小**的数组 $a$，满足以下条件：
- 对于每个 $1 \leq i \leq n$，有 $l \leq a_i \leq r$。
- $a_1 \, \& \, a_2 \, \& \, \ldots \, \& \, a_n = a_1 \oplus a_2 \oplus \ldots \oplus a_n$，其中 $\&$ 表示**按位与**运算，$\oplus$ 表示**按位异或**运算。

如果不存在这样的数组，输出 $-1$。否则，输出 $a_k$ 。

**补充**：
- **按位与运算（&）**：对两个数的二进制表示逐位进行与运算，只有当两个对应位都为 $1$ 时，结果的该位才为 $1$，否则为 $0$。例如：$5\ \&\ 3\ =\ 1$（二进制：$101\ \&\ 011\ =\ 001$）。
- **按位异或运算（⊕）**：对两个数的二进制表示逐位进行异或运算，当两个对应位不同时，结果的该位为 $1$，相同时为 $0$。例如：$5\ \oplus\ 3\ =\ 6$（二进制：$101\ \oplus\ 011\ =\ 110$）。
#### 思路
我们需要构造一个数组，使得所有元素的按位与等于所有元素的按位异或。**根据奇偶性分类讨论**：
- 当 $n$ 为**奇数**时
	- 可以令数组所有元素均为 $l$，则 $a_1 \, \& \, a_2 \, \& \, \ldots \, \& \, a_n = a_1 \oplus a_2 \oplus \ldots \oplus a_n=l$ ，此时 $a_k = l$。
- 当 $n$ 为**偶数**时：
	- 根据按位与及按位异或的性质，易得： $a_1 \, \& \, a_2 \, \& \, \ldots \, \& \, a_n = 0$。
	- 证明：假设所有元素**按位与**结果的二进制表示中某一位为 $1$，则必须所有元素的二进制表示中该位均为 $1$，此时，所有元素**按位异或**结果在该位必然为 $0$（$n$ 为偶数），与题目要求相悖，假设不成立，因此所有元素按位与结果必为零。
	- 为了让构造的数组字典序最小，考虑将前 `n-2` 个元素置为 $l$，并让 $a_{n-1}$ 与 $a_n$ 均为大于 $l$ 的最小 $2^k$ （$k$ 为非负整数）。
因此，
- **当 $n$ 为奇数时**，所有元素都取 $l$ 即可，此时 **$a_k = l$**。
- **当 $n = 2$ 时**，不存在满足条件的数组，**无解**。
- **当 $n$ 为大于 $2$ 的偶数时**，找到 $l$ 的最高位 $t$
	- 如果 $2^{t+1} \leq r$，则构造一个数组，其中前 $n-2$ 个元素为 $l$，后 $2$ 个元素为 $2^{t+1}$。此时**若 $k \geq n-1$，则 $a_k = 2^{t+1}$，否则 $a_k = l$**。
	- 如果 $2^{t+1} > r$，则**无解**。
#### std
```cpp
#include <stdio.h>

void solve()
{
    long long n, l, r, k;
    scanf("%lld%lld%lld%lld", &n, &l, &r, &k);
    // 当 n 为奇数时，所有元素都可以取 l，此时按位与结果和按位异或结果都等于 l
    if (n & 1)
        printf("%lld\n", l);
    // 当 n = 2 时，不存在满足条件的数组
    else if (n == 2)
        puts("-1");
    // 当 n 为大于 2 的偶数时
    else
    {
        int t = 0;
        // 找到 l 的最高位位置 t
        for (int i = 63; i >= 0; i --)
            if ((l >> i) & 1)
            {
                t = i;
                break;
            }
        // 检查 2^(t + 1) 是否在范围内
        // 如果 2^(t + 1) <= r，则可以构造满足条件的数组
        // 如果 k >= n-1，则 a[k] = 2^(t + 1), 否则 a[k] = l
        // 如果 2^(t + 1) > r，则无法构造满足条件的数组，输出 -1
        printf("%lld\n", (1ll << (t + 1)) <= r ? (k >= n - 1 ? 1ll << (t + 1) : l) : -1);
    }
}

int main()
{
    int t;
    for (scanf("%d", &t); t --; )
        solve();
    return 0;
}
```
<a id="problem-G"></a>
## [G - 神秘定理](https://vjudge.net/problem/%E6%B4%9B%E8%B0%B7-P1586)
#### 题意
给定正整数 $n$，统计它能分解为**不超过四个正整数平方和**的方案总数。注意：**顺序不同的方案视为同一种方案**。
#### 思路
观察题目数据范围，$t$ 的最大值达到了 $100000$，而 $n$ 的最大值为 $32768$。如果对于每次查询都去计算一次答案，那么程序的总运行时间会非常长，必定会导致超时 (`Time Limit Exceeded`)。
这是一个典型的 **“多组查询，固定范围”** 的问题，解决方法是**预处理**。
- **预处理**：我们先创建一个数组 `ans`，大小为 $32800$ (略大于查询区间，防止`Runtime Error`)。`ans[i]` 用来存放正整数 `i` 能被分解的方案数。我们只计算一次，填充整个 `ans` 数组。
- **枚举方案**：为了计算每个数的方案数，我们使用四重循环来枚举所有可能的组合。题目要求 $25=4^{2}+3^{2}$ 和 $25=3^{2}+4^{2}$ 视为一种方案，为了避免重复计数，我们在枚举时强制规定一个顺序，例如 $a \le b \le c \le d$。这样，每一种组合都会被唯一地计算到。
- **组合方式**：题目描述为“不超过四个正整数的平方和”，但我们可以将其转换为“四个非负整数的平方和”。例如：
    -   $25 = 5^2$ 可以看作 $0^2+0^2+0^2+5^2$
    -   $25 = 3^2+4^2$ 可以看作 $0^2+0^2+3^2+4^2$
    这样，我们只需要用四个循环来枚举 $a, b, c, d$ 即可，其中它们可以为 $0$。
- **循环优化**：四个循环的嵌套非常耗时，但我们可以进行剪枝。例如，在第一个循环 `for (int a = 0; ...)` 中，当 `a * a` 已经大于等于 `N` 时，后面的循环就没有必要进行了。每一层循环都进行类似的判断，可以大大提高预处理的效率。
- **查询**：在 `init()` 函数中完成所有预处理后，对于接下来的 $t$ 次查询，我们不需要再进行任何计算。当输入一个 $n$ 时，直接以 $O(1)$ 的时间复杂度从 `ans` 数组中取出 `ans[n]` 并输出即可。
#### std
```cpp
#include <stdio.h>
const int N = 32800;
int ans[N];

// 预处理函数，计算 1 到 N - 1 范围内所有整数的分解方案数
void init()
{
    // 使用四重循环枚举所有 a, b, c, d 的组合
    // 为了防止重复计数（如 3 * 3 + 4 * 4 和 4 * 4 + 3 * 3），我们强制 a <= b <= c <= d
    for (int a = 0; a * a < N; a ++)
    {
        int t1 = a * a;
        for (int b = a; t1 + b * b < N; b ++)
        {
            int t2 = t1 + b * b;
            for (int c = b; t2 + c * c < N; c ++)
            {
                int t3 = t2 + c * c;
                for (int d = c; t3 + d * d < N; d ++)
                {
                    // 将对应和的方案数加 1
                    ans[t3 + d * d;] ++;
                }
            }
        }
    }
}

int main()
{
    // 关键步骤：在处理查询前，先调用 init() 函数进行预处理。
    // 如果没有这一步，而是对每个查询都进行四重循环，一定会超时。
    init();

    int t;
    for (scanf("%d", &t); t --; )
    {
        int n;
        scanf("%d", &n); // 读取需要分解的正整数 n
        // 直接输出预处理好的答案，时间复杂度为 O(1)
        printf("%d\n", ans[n]);
    }
    return 0;
}
```
<a id="problem-H"></a>
## [H - 爱玩数独](https://vjudge.net/problem/%E7%89%9B%E5%AE%A2-287754)
#### 题意
给定一个由 $n$ 个整数组成的数组，判断是否可以通过重新排序，使得每个长度为 $9$ 的连续子数组都包含 $1 \sim 9$ 这 $9$ 个数字。
#### 思路
要使数组成为数独数组，每个数字 $1 \sim 9$ 的出现次数必须满足：**最大出现次数与最小出现次数的差不超过 $1$**，且**每个数字至少出现一次**。
#### std
```cpp
#include <stdio.h>
const int N = 10;        // 定义数字范围 1 ~ 9
const int inf = 0x3f3f3f3f;  // 定义一个很大的数作为初始值
int cnt[N];             // 统计每个数字 1 ~ 9 出现的次数

int max(int a, int b) { return a > b ? a : b; }  // 求两个数的最大值
int min(int a, int b) { return a < b ? a : b; }  // 求两个数的最小值

int main()
{
    int n;
    scanf("%d", &n);    // 读取数组长度 n
    
    // 统计每个数字出现的次数
    for (int i = 1, x; i <= n; i ++)
    {
        scanf("%d", &x);  // 读取数组元素
        cnt[x] ++;        // 对应数字的计数器加 1
    }
    
    // 找出出现次数的最大值和最小值
    int mx = -inf, mn = inf; // 初始化 mx 为无穷小值， mn 为无穷大值
    for (int i = 1; i < N; i ++)
    {
        mx = max(mx, cnt[i]);  // 更新最大出现次数
        mn = min(mn, cnt[i]);  // 更新最小出现次数
    }
    
    // 判断是否可以重新排序为数独数组
    // 条件1：最大出现次数和最小出现次数的差不超过 1
    // 条件2：每个数字至少出现一次（即最小出现次数 >= 1）
    puts(mx - mn <= 1 && mn >= 1 ? "YES" : "NO");
    
    return 0;
}
```
<a id="problem-I"></a>
## [I - 集合大题](https://vjudge.net/problem/CodeForces-2131G)
#### 题意
给定一个初始集合 $S$ 和初始分数 $1$。进行 $k$ 次操作，每次操作取出 $S$ 中的最小值 $m$，将分数乘以 $m$，然后从 $S$ 中移除 $m$ 并向 $S$ 中加入所有 $[1, m-1]$ 的整数。求 $k$ 次操作后分数对 $10^9+7$ 取模的值。
#### 思路
不妨将集合从小到大排序，每次操作就是挑出集合最前面的数。

我们定义 $cal(n)$ 是把 $n$ 变成空集合的次数，$dp(n)$ 为 $n$ 变成空集和后对答案的贡献。
可以通过模拟求出 $n$ 比较小的 $cal(n)$ 和 $dp(n)$： （以下箭头 "$A \xrightarrow{(a, b)} B$" 含义是 $A$ 集合操作 $a$ 次后得到 $B$, 答案贡献为 $b$）

$[1] \xrightarrow{(1, 1)} \emptyset$，所以 $dp(1) = 1$，$cal(1) = 1$
$[2] \xrightarrow{(1, 2)} [1] \xrightarrow{(1, 1)} \emptyset$，所以 $dp(2) = 2 \times 1 = 2$, $cal(2) = 1 + 1 = 2$
$[3] \xrightarrow{(1, 3)} [1, 2] \xrightarrow{(1, 1)} [2] \xrightarrow{(1, 2)} [1] \xrightarrow{(1, 1)} \emptyset$，所以 $dp(3) = 3 \times 1 \times 2 = 6$， $cal(3) = 1 + 1 + 1 +1 = 4$

一般化一下，假设我们已知 $1, 2, 3，..., n - 1$ 的所有 $dp$ 和 $cal$ 的值，怎么求 $dp(n)$, $cal(n)$ (类似数学归纳法)

$[n] \xrightarrow{(1, n)} [1, 2, 3, 4,..., n - 2, n -1]$
注意到 $[n - 1] \xrightarrow{(1, n - 1)} [1, 2, 3, 4,..., n - 2] \xrightarrow{(cal(n - 1) - 1, \frac{dp(n - 1)}{n - 1})} \emptyset$，即 $[1, 2, 3, 4,..., n - 2] \xrightarrow{(cal(n - 1) - 1, \frac{dp(n - 1)}{n - 1})} \emptyset$

所以 $[n] \xrightarrow{(1, n)} [1, 2, 3, 4,..., n - 2, n -1] \xrightarrow{(cal(n - 1) - 1, \frac{dp(n - 1)}{n - 1})} [n - 1] \xrightarrow{(cal(n - 1), dp(n - 1))} \emptyset$
得出 $dp(n) = n\times \frac{dp(n - 1)}{n - 1} \times dp(n - 1)$， $cal(n) = 1 + (cal(n - 1) - 1) + cal(n - 1) = 2 \times cal(n - 1)$
易求出 $cal(n) = 2^{n - 1}$, 当 $n \geq 31$ 时候 $cal(n)$ 的值已经超过 $1e9$，所以只要预处理前 $30$ 个数

$dp(n)$ 可以简单数学变形避免模意义下的除法，用 $\frac{dp(n)}{n} = (\frac{dp(n - 1)}{n - 1})^2 \times (n - 1)$ 求出所有的 $\frac{dp(n)}{n}$ 后再求出 $dp(n)$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7;
typedef long long ll;
int a[200005], k;
ll dp[33], ans;

void dfs(int x) {
    if (x <= 31 && (1 << (x - 1)) <= k) {
        ans = ans * dp[x] % mod;
        k -= (1 << (x - 1));
    } else {
        k--;
        ans = ans * x % mod;
        for (int i = 1; i < x; i++) {
            if (k == 0) return;
            dfs(i);
        }
    }
}

int main() {
    dp[1] = 1;
    for (int i = 2; i <= 31; i++) dp[i] = dp[i - 1] * dp[i - 1] % mod * (i - 1) % mod;
    for (int i = 2; i <= 31; i++) dp[i] = dp[i] * i % mod;
    int T, n;
    cin >> T;
    while (T--) {
        cin >> n >> k;
        for (int i = 0; i < n; i++) cin >> a[i];
        sort(a, a + n);
        ans = 1;
        for (int i = 0; i < n; i++) {
            if (k == 0) break;
            dfs(a[i]);
        }
        cout << ans << '\n';
    }
    return 0;
}
```
<a id="problem-J"></a>
## [J - 送分题](https://vjudge.net/problem/%E7%89%9B%E5%AE%A2-17864)
#### 题意
改正**错误程序**：
给定一个整数 $n$，计算函数 $f(n)$ 的值。函数定义为：若 $n < 20180001$，则 $f(n) = n + 2017$；否则 $f(n) = f(f(n - 2018))$。
#### 思路
：）不会真有人直接输出了吧…

通过**打表**可以发现，对于足够大的 $n$，函数 $f(x)$ 返回值均为 $20182017$，即：
- **当 $n < 20180001$ 时，直接返回 $n + 2017$。**
- **当 $n \geq 20180001$ 时， 返回 $20182017$。**

分段函数， 难点主要是 $x\geq20180001$ 那部分，
可以先研究简单情况比如 $20180001, 20180002\cdots$ 的值,发现它们都是 $20182017$
然后猜想， 最后数学归纳法
略证:
设 $x \geq 20180001$
假设 $f(20180000), f(20180002),\cdots, f(x - 1)$ 的值都是 $20182017$
如果 $x \leq 20182017$, 那么 $f(x) = f(f(x - 2018)) = f(x - 2018 + 2017) = f(x - 1) = 20182017$
否则 $x > 20182017$ ， 那么 $x - 2018 \geq 20180000$ , 所以 $f(x - 2018) = 20182017,\ f(x) = f(f(x - 2018)) = f(20182017) = 20182017$
又 $f(20180000)$ 值是 $20182017$ ， 由数学归纳法知道， 对于 $x \geq 20180001, f(x) = 20182017$

```cpp
#include<stdio.h> // 打表程序

long long f(long long n)
{
    if (n < 20180001) return n + 2017;
    return f(f(n - 2018));
}

int main()
{
    long long n;
    for (n = 20180001; n <= 20181000; n ++)
        printf("%lld -- %lld\n", n, f(n));
    return 0;
}
```
```
20180001 -- 20182017
20180002 -- 20182017
20180003 -- 20182017
20180004 -- 20182017
20180005 -- 20182017
20180006 -- 20182017
···
20180018 -- 20182017
20180019 -- 20182017
20180020 -- 20182017
20180021 -- 20182017
20180022 -- 20182017
20180023 -- 20182017
20180024 -- 20182017
···
```
#### std
```cpp
#include<stdio.h> // step1：照搬题目所给代码

long long f(long long n)
{
    if (n < 20180001) return n + 2017;
    return 20182017; // step2：打表找规律
}

int main()
{
    long long n;
    scanf("%lld", &n); // step3：蔡神的小心思
    printf("%lld", f(n));
    return 0;
}
```